{
  "hash": "62bd136fd010dd4a2de9cf158af492f9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"day 11_stripes\"\nauthor:\n  - name: Jen Richmond\n    url: https://jenrichmond.github.io/\ndate: 2025-04-11\nformat: html\neditor: source\nimage: featured.png\nexecute:\n  freeze: true\n---\n\n\n\n\nDeparting from Our World in Data today to try and make a [\"show your stripes\"](https://showyourstripes.info/b/australasia/newzealand/all) temperature plot.\n\n![](NZstripes.png)\n\nThis was much easier than I expected because I just followed these beautiful instructions from [Dominic Roye](https://dominicroye.github.io/blog/how-to-create-warming-stripes-in-r/index.html).\n\nData from [StatsNZ](https://www.stats.govt.nz/indicators/temperature/).\n\n### set up\n\nHere I am loading packages and defining `theme_strip` (code copied from Dominic's blog)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(janitor)\nlibrary(RColorBrewer)\nlibrary(ggeasy)\n\n\ntheme_strip <- function(){ \n  \n  theme_minimal() %+replace%\n  theme(\n    axis.text.y = element_blank(),\n    axis.line.y = element_blank(),\n    axis.title = element_blank(),\n    panel.grid.major = element_blank(),\n    legend.title = element_blank(),\n    axis.text.x = element_text(vjust = 3),\n    panel.grid.minor = element_blank(),\n    plot.title = element_text(size = 14, face = \"bold\"),\n    legend.key.width = unit(.5, \"lines\")\n  )\n}\n\ncol_strip <- brewer.pal(11, \"RdBu\")\n```\n:::\n\n\n\n\n### read the data\n\nHere I am reading the data from Stats NZ and filtering it to only include the site closest to where I live.\n\nThe dataset had daily temperature values and I really only needed the average temp for each year so I `group_by` year and `summarise` the mean temperature.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- read_csv(here(\"charts\", \"2025-04-11_stripes\", \"daily-temperature-for-30-sites-to-2022-part2.csv\"))\n\nq <- temp %>%\n  filter(site ==  \"Queenstown (Otago)\") %>%\n  mutate(site = str_sub(site, 1, -9)) \n\nqmean <- q %>%\n  filter(statistic == \"Average\") %>%\n  group_by(year(date)) %>%\n  summarise(annual = mean(temperature)) %>%\n  rename(date = `year(date)`)\n\nglimpse(qmean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 51\nColumns: 2\n$ date   <dbl> 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 198…\n$ annual <dbl> 9.631421, 9.964384, 9.929041, 9.853973, 9.092077, 8.694247, 9.8…\n```\n\n\n:::\n:::\n\n\n\n\n### plot \n\nI hadn't used `geom_tile` before. Here I am defining the colour of the tile fill to be the annual average temperature.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqmean %>%\n    ggplot(aes(x = date, y = 1, fill = annual)) +\n  geom_tile() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\nTo get the colour scale to represent how far the annual temperature is from average, this chunk defines the min, max and mean across the whole dataset and then uses scale_fill_gradient() to colour the tiles.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxmin <- range(qmean$annual, na.rm = T)\nmd <- mean(qmean$annual, na.rm = T)\n\n\nqmean %>%\n    ggplot(aes(x = date, y = 1, fill = annual)) +\n  geom_tile() +\n  scale_fill_gradientn(colors = rev(col_strip), \n                       values = scales::rescale(c(maxmin[1], md, maxmin[2])), \n                       na.value = \"gray80\") +\n  scale_x_continuous(limits = c(1972, 2022), expand = c(0,0), breaks = seq(1972,2022, 10)) +\n  labs(\n    title = \"Queenstown 1972-2022\",\n    caption = \"Data: Stats NZ\", \n    x = \"Year\") +\n  coord_cartesian(expand = FALSE) +\n  theme_strip() +\n  easy_remove_axes(which = \"x\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nToo easy! Thanks Dominic!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}