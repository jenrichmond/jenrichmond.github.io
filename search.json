[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "blog",
    "section": "",
    "text": "Want to support my blog? \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlearning python\n\n\n\npython\n\n\n\n\n\n\n\nJen Richmond\n\n\nJul 4, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrowwise %&gt;% mean\n\n\n\ndata wrangling\n\n\n\n\n\n\n\nJen Richmond\n\n\nMay 24, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nerror bars on plots\n\n\n\nidhgt\n\n\nggplot\n\n\n\n\n\n\n\nJen Richmond\n\n\nApr 25, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncolours that R knows\n\n\n\nggplot\n\n\n\n\n\n\n\nJen Richmond\n\n\nDec 14, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngit hints\n\n\n\n\n\n\nJen Richmond\n\n\nSep 28, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nusing lists in R\n\n\n\n\n\n\nJen Richmond\n\n\nJun 27, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmy favourite things about R\n\n\n\n\n\n\nJen Richmond\n\n\nJan 17, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPAT for GitHub\n\n\n\n\n\n\nJen Richmond\n\n\nJun 22, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncleaning penguins with the janitor package\n\n\n\n\n\n\nJen Richmond\n\n\nNov 18, 2020\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-05-24-rowwise-mean/index.html",
    "href": "posts/2023-05-24-rowwise-mean/index.html",
    "title": "rowwise %>% mean",
    "section": "",
    "text": "When you have data from a survey, the responses for each item are most often listed in different variables. Generally you have to average across the items to get a mean value for that scale for each participant. But dealing with calculations across rows is sometimes difficult in R.\n\nPhoto by Travis Essinger on Unsplash\n\nload packages + make some data\n\nlibrary(tidyverse)\n\n\npID &lt;- c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\")\nitem1 = sample(1:7, 6, replace=T)\nitem2 = sample(1:7, 6, replace=T)\nitem3 = sample(1:7, 6, replace=T)\nitem4 = sample(1:7, 6, replace=T)\nitem5 = sample(1:7, 6, replace=T)\n\nsurvey &lt;- data.frame(pID, item1, item2, item3, item4, item5)\n\nglimpse(survey)\n\nRows: 6\nColumns: 6\n$ pID   &lt;chr&gt; \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"\n$ item1 &lt;int&gt; 4, 1, 7, 7, 2, 5\n$ item2 &lt;int&gt; 2, 7, 6, 7, 7, 5\n$ item3 &lt;int&gt; 3, 1, 7, 6, 6, 7\n$ item4 &lt;int&gt; 1, 7, 1, 5, 6, 6\n$ item5 &lt;int&gt; 1, 5, 1, 6, 4, 2\n\n\n\n\nbase R rowMeans\nThe rowMeans() function works, but why the x and what do the dots mean??\n\nsurvey_means_base &lt;- survey %&gt;%\n  mutate(item_mean = rowMeans(x = select(.data = . , starts_with(match = \"item\"))))\n\n\n\ntidyverse rowwise\nThe tidyverse version involves using rowwise() to tell R that you would like a mean calculated for each row in the dataset. Use c() to tell R which columns to average across.\nWithout rowwise(), R will calculate the mean of all rows/columns and put that in the new variable. You will end up with the same value for each row.\n\nsurvey_means_norowwise &lt;- survey %&gt;%\n  mutate(item_mean = mean(c(item1, item2, item3, item4, item5))) \n\nglimpse(survey_means_norowwise)\n\nRows: 6\nColumns: 7\n$ pID       &lt;chr&gt; \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"\n$ item1     &lt;int&gt; 4, 1, 7, 7, 2, 5\n$ item2     &lt;int&gt; 2, 7, 6, 7, 7, 5\n$ item3     &lt;int&gt; 3, 1, 7, 6, 6, 7\n$ item4     &lt;int&gt; 1, 7, 1, 5, 6, 6\n$ item5     &lt;int&gt; 1, 5, 1, 6, 4, 2\n$ item_mean &lt;dbl&gt; 4.5, 4.5, 4.5, 4.5, 4.5, 4.5\n\n\nWith rowwise(), it calculates across the rows, separately for each participant.\n\n\n\n\n\n\nNote\n\n\n\nIt is important to get into the habit of adding ungroup() after a rowwise() in the same way as you would after a group_by() because the dataframe becomes grouped by row, which can mess with calcuations further down the pipeline.\n\n\n\nsurvey_means_rowwise &lt;- survey %&gt;%\n  rowwise() %&gt;%\n  mutate(item_mean = mean(c(item1, item2, item3, item4, item5))) %&gt;%\n  ungroup()\n\nglimpse(survey_means_rowwise)\n\nRows: 6\nColumns: 7\n$ pID       &lt;chr&gt; \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"\n$ item1     &lt;int&gt; 4, 1, 7, 7, 2, 5\n$ item2     &lt;int&gt; 2, 7, 6, 7, 7, 5\n$ item3     &lt;int&gt; 3, 1, 7, 6, 6, 7\n$ item4     &lt;int&gt; 1, 7, 1, 5, 6, 6\n$ item5     &lt;int&gt; 1, 5, 1, 6, 4, 2\n$ item_mean &lt;dbl&gt; 2.2, 4.2, 4.4, 6.2, 5.0, 5.0\n\n\nIf there are a lot of columns to average across, you can avoid typing all of the names using c_across().\n\nsurvey_means_rowwise_across &lt;- survey %&gt;%\n  rowwise() %&gt;%\n  mutate(item_mean = mean(c_across(item1:item5))) %&gt;%\n  ungroup()\n\nglimpse(survey_means_rowwise_across)\n\nRows: 6\nColumns: 7\n$ pID       &lt;chr&gt; \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"\n$ item1     &lt;int&gt; 4, 1, 7, 7, 2, 5\n$ item2     &lt;int&gt; 2, 7, 6, 7, 7, 5\n$ item3     &lt;int&gt; 3, 1, 7, 6, 6, 7\n$ item4     &lt;int&gt; 1, 7, 1, 5, 6, 6\n$ item5     &lt;int&gt; 1, 5, 1, 6, 4, 2\n$ item_mean &lt;dbl&gt; 2.2, 4.2, 4.4, 6.2, 5.0, 5.0"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html",
    "title": "my favourite things about R",
    "section": "",
    "text": "I am prepping a talk for R-Ladies Sydney about my favourite R things, including the packages and functions that end up in every script I write.\nlibrary(tidyverse)\nlibrary(here)\nlibrary(janitor)\nlibrary(lubridate)\nlibrary(ggeasy)\nlibrary(palmerpenguins)\nlibrary(naniar)\nlibrary(gt)"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#herehere",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#herehere",
    "title": "my favourite things about R",
    "section": "here::here()",
    "text": "here::here()\nThe here package makes dealing with file paths and telling R where your work lives really easy. If you work within a R project (always recommended), here::here() defaults to the top level of your project folder. You can refer to everything relative to there and use quotes to specify folder levels. Today I am writing in my website project, so here tells me that I am currently…\n\nhere::here()\n\n[1] \"/home/runner/work/jenrichmond.github.io/jenrichmond.github.io\"\n\n\nWhen I want to read in some data, I can refer to the location of that data relative to this starting point. In my blogdown site, I’ve put the data in the folder for this particular post (within content/blog/). The nice thing about referring to the location of things relative to the top level of your project, is that it doesn’t matter if you are working in Rmd or R script, on the computer that you wrote the code on or another one, the path doesn’t change.\n\npractice_penguins &lt;- read_csv(here(\"posts\", \"2022-01-17-my-favourite-things-about-r\", \"practice_penguins.csv\"))"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#janitorclean_names",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#janitorclean_names",
    "title": "my favourite things about R",
    "section": "janitor::clean_names()",
    "text": "janitor::clean_names()\nI messed up the penguin data to make the variable names a bit ugly so I could demo my favourite function, clean_names(). So often little thought is put into naming conventions at the time of data entry and it is really common to be given a dataset that has really longwinded and inconsistently formatted variable names.\n\nnames(practice_penguins)\n\n[1] \"Species\"        \"island\"         \"Bill length\"    \"bill_depth\"    \n[5] \"flipper length\" \"Body_Mass\"      \"Sex\"            \"year\"          \n\n\nIn this case there is a mix of upper and lower case, some gaps between words, some underscores. When you are coding, you need to type the names of variables a lot, so it can save you lots of time to make the variable names consistent… enter clean_names()\n\nclean_penguins &lt;- practice_penguins %&gt;%\n  clean_names()\n\nnames(clean_penguins)\n\n[1] \"species\"        \"island\"         \"bill_length\"    \"bill_depth\"    \n[5] \"flipper_length\" \"body_mass\"      \"sex\"            \"year\"          \n\n\nIn one line of code, everything is lower case with underscores in the gaps (aka snake case)."
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#janitortabyl",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#janitortabyl",
    "title": "my favourite things about R",
    "section": "janitor::tabyl()",
    "text": "janitor::tabyl()\nOften the first thing you want to do in R is count how many observations you have of different type. The tabyl() function from janitor works much like the count() function, but the output is more concise and user friendly and includes percentages automatically.\n\nclean_penguins %&gt;%\n  tabyl(species) \n\n   species   n   percent\n    Adelie 152 0.4418605\n Chinstrap  68 0.1976744\n    Gentoo 124 0.3604651\n\n\nYou can count just one variable, or get something a bit like a cross tab with two. There are a series of adorn_ functions that also allow you to add totals.\n\nclean_penguins %&gt;%\n  tabyl(species, sex) %&gt;%\n  adorn_totals() \n\n   species female male NA_\n    Adelie     73   73   6\n Chinstrap     34   34   0\n    Gentoo     58   61   5\n     Total    165  168  11\n\n\nYou can assign the output to a dataframe or pipe into gt() to get a nice looking rendered output.\n\nclean_penguins %&gt;%\n  tabyl(species, sex) %&gt;%\n  adorn_totals() %&gt;%\n  gt()\n\n\n\n\n\n\n\nspecies\nfemale\nmale\nNA_\n\n\n\n\nAdelie\n73\n73\n6\n\n\nChinstrap\n34\n34\n0\n\n\nGentoo\n58\n61\n5\n\n\nTotal\n165\n168\n11"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#naniarvis_miss",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#naniarvis_miss",
    "title": "my favourite things about R",
    "section": "naniar::vis_miss",
    "text": "naniar::vis_miss\nSometimes you know there is missing data but it can be difficult to know where it is or what to do about it. The vis_miss() function from the naniar` package helps you see where the missing values are so you can better decide what to do with them.\n\nnaniar::vis_miss(clean_penguins)"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#tidyrpivot_longer",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#tidyrpivot_longer",
    "title": "my favourite things about R",
    "section": "tidyr::pivot_longer()",
    "text": "tidyr::pivot_longer()\nWhen we enter data it is usually in wide format. This is problematic when you want to use ggplot, which expects your data to be long. The new pivot functions from tidyr make it really easy to switch your data from wide to long (and back again if you need). Here I am selecting just species and the two variables that start with “bill” to make a smaller demo dataset.\n\npenguin_bill &lt;- clean_penguins %&gt;%\n  select(species, starts_with(\"bill\"))\n\nglimpse(penguin_bill)\n\nRows: 344\nColumns: 3\n$ species     &lt;chr&gt; \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\", \"Adelie\"…\n$ bill_length &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, 42.0, …\n$ bill_depth  &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, 20.2, …\n\n\nTechnically this bill data is in wide format (it is not the best example but lets run with it). The two columns contain bill measurements, about two different parts of the penguin bill. We could represent this data in long format by making a new column that contained info about which part of the bill we were measuring, and another column with the measurement value.\nThe pivot_longer() function asks you to specify what you want to call the column that will contain what is currently in the variable names (i.e. names_to), what you want to call the column that will contain the values (i.e. values to) and the range of columns that are currently wide that you want to be long.\n\nlong_bill &lt;- penguin_bill %&gt;%\n  pivot_longer(names_to = \"bill_part\", \n               values_to = \"measurement\",   bill_length:bill_depth)\n\nhead(long_bill)\n\n# A tibble: 6 × 3\n  species bill_part   measurement\n  &lt;chr&gt;   &lt;chr&gt;             &lt;dbl&gt;\n1 Adelie  bill_length        39.1\n2 Adelie  bill_depth         18.7\n3 Adelie  bill_length        39.5\n4 Adelie  bill_depth         17.4\n5 Adelie  bill_length        40.3\n6 Adelie  bill_depth         18"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#ggeasyeasy_remove_legend",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#ggeasyeasy_remove_legend",
    "title": "my favourite things about R",
    "section": "ggeasy::easy_remove_legend()",
    "text": "ggeasy::easy_remove_legend()\nOnce you have your head around how to construct figures in ggplot, you can spend a lot of time googling how to customise it. The ggeasy package contains a whole lot of easy to use wrappers for really common ggplot adjustments. Like removing the legend…the code to remove the legend is p + theme(legend.position = \"none\") … or you can use ggeasy::easy_remove_legend()\n\nlong_bill %&gt;% \n  ggplot(aes(x = species, y = measurement, colour = species)) +\n  geom_jitter(width = 0.2, alpha = 0.5) +\n  facet_wrap(~ bill_part) +\n  easy_remove_legend()"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#dplyrcase_when",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#dplyrcase_when",
    "title": "my favourite things about R",
    "section": "dplyr::case_when()",
    "text": "dplyr::case_when()\nSometimes you need to compute a new variable based on values in other variables, case_when() is your friend. Lets say we were interested in which penguins have extremely long or short bills. Here I am filtering for just the Gentoo penguins, and calculating the mean and sd for bill length. Then I am using mutate() to make a new variable and case_when() to flag values of bill length than are more than 2sd greater than the mean as “long” and values of bill length that are more than 2sd below the mean as short. The TRUE ~ “ordinary”, puts ordinary in the cells that don’t meet those criteria.\nThen we can use tabyl() to count how many penguins have extraordinarily long or short bills.\n\ngentoo &lt;- clean_penguins %&gt;%\n  filter(species == \"Gentoo\") %&gt;%\n  select(species, bill_length, sex)\n\nmean_length &lt;- mean(gentoo$bill_length, na.rm = TRUE)\nsd_length &lt;- sd(gentoo$bill_length, na.rm = TRUE)\n\ngentoo &lt;- gentoo %&gt;%\n  mutate(long_short = case_when(bill_length &gt; mean_length + 2*sd_length ~ \"long\", \n                         bill_length &lt; mean_length - 2*sd_length ~ \"short\",\n                         TRUE ~ \"ordinary\"))\n\ngentoo %&gt;% tabyl(long_short)\n\n long_short   n     percent\n       long   4 0.032258065\n   ordinary 119 0.959677419\n      short   1 0.008064516"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#dplyrrelocate",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#dplyrrelocate",
    "title": "my favourite things about R",
    "section": "dplyr::relocate()",
    "text": "dplyr::relocate()\nWhen using mutate() to make a new variable, the default is to add it to the right side of the dataframe. With small datasets that is ok, but when you have lots of variables and you want to check whether the mutate has done what you want, it can be annoying. There is a relatively new function in dplyr that allows you to relocate a variable. Here I am moving the long_short variable we just made to the position after bill_length.\n\ngentoo &lt;- gentoo %&gt;%\n  relocate(long_short, .after = bill_length)\n\nglimpse(gentoo)\n\nRows: 124\nColumns: 4\n$ species     &lt;chr&gt; \"Gentoo\", \"Gentoo\", \"Gentoo\", \"Gentoo\", \"Gentoo\", \"Gentoo\"…\n$ bill_length &lt;dbl&gt; 46.1, 50.0, 48.7, 50.0, 47.6, 46.5, 45.4, 46.7, 43.3, 46.8…\n$ long_short  &lt;chr&gt; \"ordinary\", \"ordinary\", \"ordinary\", \"ordinary\", \"ordinary\"…\n$ sex         &lt;chr&gt; \"female\", \"male\", \"female\", \"male\", \"male\", \"female\", \"fem…\n\n\nLets make a plot to illustrate the variability in Gentoo penguins bill length.\n\ngentoo %&gt;%\n  ggplot(aes(x = sex, y = bill_length, colour = long_short)) + \n  geom_jitter(width = 0.2)"
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#knitr-options-fig.path",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#knitr-options-fig.path",
    "title": "my favourite things about R",
    "section": "knitr options fig.path =",
    "text": "knitr options fig.path =\nYou might have noticed that in the default Rmd template there is a chunk at the top that controls how your document knits. The default knit settings have echo = TRUE which makes your code appear in your knitted document along with your output. But you can add other knit settings.\n\n\n\n\n\n\n\n\n\nYou can add fig.width, fig.height, and fig.path to control how big your plots appear in your knitted document. You can also add fig.path to have your plots be rendered in png format to a folder within your project. And if you want all the ggplots in your document to be the same theme, you can add that as a default."
  },
  {
    "objectID": "posts/2022-01-17-my-favourite-things-about-r/index.html#readrwrite_csv",
    "href": "posts/2022-01-17-my-favourite-things-about-r/index.html#readrwrite_csv",
    "title": "my favourite things about R",
    "section": "readr::write_csv()",
    "text": "readr::write_csv()\nMy data analysis process often involves reading in raw data, cleaning it up, and then writing it out to csv so that you can read the clean data in to another process (visualisation, modelling). I use write_csv() and here::here() to write out a csv that can then be used in a different script.\n\ngentoo %&gt;%\n  write_csv(\"clean_gentoo.csv\")"
  },
  {
    "objectID": "posts/2020-11-18-digging-into-the-janitor-package/index.html",
    "href": "posts/2020-11-18-digging-into-the-janitor-package/index.html",
    "title": "cleaning penguins with the janitor package",
    "section": "",
    "text": "The janitor package by Sam Firke contains probably my FAVOURITE R function: clean_names().\nBy default when I am reading data into R, I always pipe clean_names() onto the end of my read_csv(). That way, I never have to look at inconsistently formatted variable names. But janitor package includes lots of other useful functions that make it easier to deal with dirty data and count stuff.\n\nExploring package functions\nAre you keen to dig into the little known functions of a package that you use all the time? Here is a tip: in console type the name of the package with a double colon (i.e. janitor::), all the functions in the package will pop up and you can explore them by scrolling up and down the list.\nAlternatively you can load the package in the console and then use ls(package:packagename) to get a list of all the objects in the package.\n\nlibrary(janitor)\n\nls(package:janitor)\n\n [1] \"%&gt;%\"                   \"add_totals_col\"        \"add_totals_row\"       \n [4] \"adorn_crosstab\"        \"adorn_ns\"              \"adorn_pct_formatting\" \n [7] \"adorn_percentages\"     \"adorn_rounding\"        \"adorn_title\"          \n[10] \"adorn_totals\"          \"as_tabyl\"              \"chisq.test\"           \n[13] \"clean_names\"           \"compare_df_cols\"       \"compare_df_cols_same\" \n[16] \"convert_to_date\"       \"convert_to_datetime\"   \"convert_to_NA\"        \n[19] \"crosstab\"              \"describe_class\"        \"excel_numeric_to_date\"\n[22] \"find_header\"           \"fisher.test\"           \"get_dupes\"            \n[25] \"get_one_to_one\"        \"make_clean_names\"      \"remove_constant\"      \n[28] \"remove_empty\"          \"remove_empty_cols\"     \"remove_empty_rows\"    \n[31] \"round_half_up\"         \"round_to_fraction\"     \"row_to_names\"         \n[34] \"sas_numeric_to_date\"   \"signif_half_up\"        \"single_value\"         \n[37] \"tabyl\"                 \"top_levels\"            \"untabyl\"              \n[40] \"use_first_valid_of\"   \n\n\nLets try a few these functions.\n\n\nread some dirty data\nThe penguin data isn’t very dirty out of the package, but I added some funky things for illustrative purposes.\n\ndirty &lt;- read_csv(\"penguin_raw_dirty.csv\")\n\n\n\n1. clean_names()\nThe penguin variable names are not great. A nasty mix of capital and little letters, gaps and brackets- not fun to type over and over again.\n\nnames(dirty)\n\n [1] \"studyName\"           \"Sample Number\"       \"Species\"            \n [4] \"Region\"              \"Island\"              \"Stage\"              \n [7] \"Individual ID\"       \"Clutch Completion\"   \"Empty Column\"       \n[10] \"Date Egg\"            \"Culmen Length (mm)\"  \"Culmen Depth (mm)\"  \n[13] \"Flipper Length (mm)\" \"Body Mass (g)\"       \"Sex\"                \n[16] \"Delta 15 N (o/oo)\"   \"Delta 13 C (o/oo)\"   \"Comments\"           \n\n\nclean_names() will take all the variable names and make them lower case and replace gaps/brackets with underscores.\n\nclean &lt;- dirty %&gt;%\n  clean_names()\n\nnames(clean)\n\n [1] \"study_name\"        \"sample_number\"     \"species\"          \n [4] \"region\"            \"island\"            \"stage\"            \n [7] \"individual_id\"     \"clutch_completion\" \"empty_column\"     \n[10] \"date_egg\"          \"culmen_length_mm\"  \"culmen_depth_mm\"  \n[13] \"flipper_length_mm\" \"body_mass_g\"       \"sex\"              \n[16] \"delta_15_n_o_oo\"   \"delta_13_c_o_oo\"   \"comments\"         \n\n\n\n\n2. remove_empty()\nSometimes dirty data contains whole rows or columns that are empty. You can quickly remove them with remove_empty(). By default it is a “quiet” function, but specify quiet = FALSE and it will give you a little feedback about what it has done.\n\nempty &lt;- clean %&gt;%\n  remove_empty(which = c(\"rows\", \"cols\"), quiet = FALSE)\n\nRemoving 1 empty rows of 347 rows total (0.288%).\n\n\nRemoving 1 empty columns of 18 columns total (Removed: empty_column).\n\n\n\n\n3. get dupes()\nLets imagine an RA made a mistake and entered the data for a couple of penguins twice. The get_dupes() function will tell you if there are duplicate entries in your dataset.\n\nempty %&gt;%\n  get_dupes(sample_number, species)\n\n# A tibble: 4 × 18\n  sample_number species  dupe_count study_name region island stage individual_id\n          &lt;dbl&gt; &lt;chr&gt;         &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;        \n1            18 Adelie …          2 PAL0708    Anvers Torge… Adul… N9A2         \n2            18 Adelie …          2 PAL0708    Anvers Torge… Adul… N9A2         \n3            60 Chinstr…          2 PAL0910    Anvers Dream  Adul… N95A2        \n4            60 Chinstr…          2 PAL0910    Anvers Dream  Adul… N95A2        \n# ℹ 10 more variables: clutch_completion &lt;chr&gt;, date_egg &lt;chr&gt;,\n#   culmen_length_mm &lt;dbl&gt;, culmen_depth_mm &lt;dbl&gt;, flipper_length_mm &lt;dbl&gt;,\n#   body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, delta_15_n_o_oo &lt;dbl&gt;, delta_13_c_o_oo &lt;dbl&gt;,\n#   comments &lt;chr&gt;\n\n\nThen you can remove the duplicates with the distinct() function from dplyr. It only keeps distinct observations.\n\ndupes_gone &lt;- empty %&gt;%\n  distinct()\n\ndupes_gone %&gt;%\n  get_dupes(sample_number, species)\n\nNo duplicate combinations found of: sample_number, species\n\n\n# A tibble: 0 × 18\n# ℹ 18 variables: sample_number &lt;dbl&gt;, species &lt;chr&gt;, dupe_count &lt;int&gt;,\n#   study_name &lt;chr&gt;, region &lt;chr&gt;, island &lt;chr&gt;, stage &lt;chr&gt;,\n#   individual_id &lt;chr&gt;, clutch_completion &lt;chr&gt;, date_egg &lt;chr&gt;,\n#   culmen_length_mm &lt;dbl&gt;, culmen_depth_mm &lt;dbl&gt;, flipper_length_mm &lt;dbl&gt;,\n#   body_mass_g &lt;dbl&gt;, sex &lt;chr&gt;, delta_15_n_o_oo &lt;dbl&gt;, delta_13_c_o_oo &lt;dbl&gt;,\n#   comments &lt;chr&gt;\n\n\n\n\n4. tabyl()\nBut perhaps the most surprisingly awesome function in the janitor package is tabyl(). Counting things in R is surprisingly hard see post, but tabyl() is a huge help.\nAdvantages…\n\nworks with %&gt;%\ntakes a dataframe\noutputs a dataframe\nis compatible with other table packages like kableExtra and gt\n\n\none variable (gets you %)\n\ndupes_gone %&gt;%\n  tabyl(species) \n\n                                   species   n   percent\n       Adelie Penguin (Pygoscelis adeliae) 152 0.4418605\n Chinstrap penguin (Pygoscelis antarctica)  68 0.1976744\n         Gentoo penguin (Pygoscelis papua) 124 0.3604651\n\n\n\n\ntwo variables\n\ndupes_gone %&gt;%\n  tabyl(species, sex)\n\n                                   species . FEMALE MALE NA_\n       Adelie Penguin (Pygoscelis adeliae) 0     73   73   6\n Chinstrap penguin (Pygoscelis antarctica) 0     34   34   0\n         Gentoo penguin (Pygoscelis papua) 1     58   61   4\n\n\nHmmmm why is there a “.” column? Turns out for one penguin their sex is entered as “.” instead of NA.\nUse na_if() from dplyr to convert pesky values to NA.\n\ndupes_gone$sex &lt;-  na_if(dupes_gone$sex, \".\")\n\ndupes_gone %&gt;%\n  tabyl(species, sex)\n\n                                   species FEMALE MALE NA_\n       Adelie Penguin (Pygoscelis adeliae)     73   73   6\n Chinstrap penguin (Pygoscelis antarctica)     34   34   0\n         Gentoo penguin (Pygoscelis papua)     58   61   5\n\n\n\n\nthree variables\n\ndupes_gone %&gt;%\n  tabyl(species, sex, island) \n\n$Biscoe\n                                   species FEMALE MALE NA_\n       Adelie Penguin (Pygoscelis adeliae)     22   22   0\n Chinstrap penguin (Pygoscelis antarctica)      0    0   0\n         Gentoo penguin (Pygoscelis papua)     58   61   5\n\n$Dream\n                                   species FEMALE MALE NA_\n       Adelie Penguin (Pygoscelis adeliae)     27   28   1\n Chinstrap penguin (Pygoscelis antarctica)     34   34   0\n         Gentoo penguin (Pygoscelis papua)      0    0   0\n\n$Torgersen\n                                   species FEMALE MALE NA_\n       Adelie Penguin (Pygoscelis adeliae)     24   23   5\n Chinstrap penguin (Pygoscelis antarctica)      0    0   0\n         Gentoo penguin (Pygoscelis papua)      0    0   0\n\n\n\n\nadorn_ ing things\n\ntotals by row and/or col\n\ndupes_gone %&gt;%\n  tabyl(species, sex) %&gt;%\n  adorn_totals(c(\"row\", \"col\"))\n\n                                   species FEMALE MALE NA_ Total\n       Adelie Penguin (Pygoscelis adeliae)     73   73   6   152\n Chinstrap penguin (Pygoscelis antarctica)     34   34   0    68\n         Gentoo penguin (Pygoscelis papua)     58   61   5   124\n                                     Total    165  168  11   344\n\n\n\n\npercentages\n\ndupes_gone %&gt;%\n  tabyl(species, sex) %&gt;%\n  adorn_percentages(\"row\")\n\n                                   species    FEMALE      MALE        NA_\n       Adelie Penguin (Pygoscelis adeliae) 0.4802632 0.4802632 0.03947368\n Chinstrap penguin (Pygoscelis antarctica) 0.5000000 0.5000000 0.00000000\n         Gentoo penguin (Pygoscelis papua) 0.4677419 0.4919355 0.04032258\n\n\n\n\npercent formatting\n\n  dupes_gone %&gt;%\n  tabyl(species, sex) %&gt;%\n  adorn_percentages(\"row\") %&gt;%\n  adorn_pct_formatting()\n\n                                   species FEMALE  MALE  NA_\n       Adelie Penguin (Pygoscelis adeliae)  48.0% 48.0% 3.9%\n Chinstrap penguin (Pygoscelis antarctica)  50.0% 50.0% 0.0%\n         Gentoo penguin (Pygoscelis papua)  46.8% 49.2% 4.0%\n\n\n\n\n\n\n5. tabyl + other nice tables (kableExtra, gt)\nThe nice thing is that the output of tabyl() can be assigned as a dataframe object in your environment OR you can pipe on a kable()…\n\ndupes_gone %&gt;%\n  tabyl(species, sex) %&gt;%\n  adorn_percentages(\"row\") %&gt;%\n  adorn_pct_formatting() %&gt;%\n  kable() \n\n\n\n\nspecies\nFEMALE\nMALE\nNA_\n\n\n\n\nAdelie Penguin (Pygoscelis adeliae)\n48.0%\n48.0%\n3.9%\n\n\nChinstrap penguin (Pygoscelis antarctica)\n50.0%\n50.0%\n0.0%\n\n\nGentoo penguin (Pygoscelis papua)\n46.8%\n49.2%\n4.0%\n\n\n\n\n\n… or a gt() to get a really nicely formatted summary table\n\ndupes_gone %&gt;%\n  tabyl(species, sex) %&gt;%\n  adorn_percentages(\"row\") %&gt;%\n  adorn_pct_formatting() %&gt;%\n  gt()\n\n\n\n\n\n\n\nspecies\nFEMALE\nMALE\nNA_\n\n\n\n\nAdelie Penguin (Pygoscelis adeliae)\n48.0%\n48.0%\n3.9%\n\n\nChinstrap penguin (Pygoscelis antarctica)\n50.0%\n50.0%\n0.0%\n\n\nGentoo penguin (Pygoscelis papua)\n46.8%\n49.2%\n4.0%"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html",
    "href": "charts/2025-03-31_challenge/index.html",
    "title": "day 0 challenge",
    "section": "",
    "text": "I have some time on my hands at the moment and thought the #30DayChartChallenge might be a good way to refresh my ggplot skills.\nThe Our World in Data is a fun place to explore data visualisations. They always make really interesting plots out of all kinds of different data, but they use an in-house data viz platform called “Grapher” so it isn’t easy to find code that can be used to reproduce the charts.\nMy goal in April is use the 30 day chart challenge prompt to find a Our World in Data plot that looks interesting, and then to try to reproduce the plot using ggplot code.\nI will post the final code for each plot in a tabset below, but if you want to see how each chart came about (i.e. my troubleshooting process), there will be a blog post associated with each one.\nThe owidapi package is an easy way to get access to the data sources that the Our World in Data site uses.\nlibrary(owidapi)\n\ncatalog &lt;- owid_get_catalog()\n\nwillingness &lt;- owid_get(\"willingness-climate-action\")"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-1-fractions",
    "href": "charts/2025-03-31_challenge/index.html#day-1-fractions",
    "title": "day 0 challenge",
    "section": "Day 1 fractions",
    "text": "Day 1 fractions\nWillingness climate action\n\nmy plotr code\n\n\n\n\n\n\nwillingness2024 %&gt;%\n  filter(entity_name != \"World\") %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness, colour = region)) +\n  geom_point() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n    scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                       limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\", \n       title = \"People underestimate others' willingness to take climate action\", \n       subtitle = \"Participants were asked if they would contribute 1% of their income to tackle \\nclimate change. \\nThe share that answered 'yes' is shown on the horizontal axis. \\nThe share of the population in their country that people think would be willing \\nis shown on the vertical axis.\") +\n  theme_bw()  +\n  easy_remove_gridlines(axis = \"both\", minor = TRUE, major = FALSE) +\n  geom_abline(\n    slope = 1, \n    intercept = 0, \n    color = \"grey\", \n    linetype = \"dotted\") +\n  scale_colour_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#883039\")) +\n  easy_remove_legend_title() +\n  geom_text_repel(aes(label = entity_name), size = 3, max.overlaps = 20)"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-2-slope",
    "href": "charts/2025-03-31_challenge/index.html#day-2-slope",
    "title": "day 0 challenge",
    "section": "Day 2 slope",
    "text": "Day 2 slope\nTime spent alone\n\nmy plotr code\n\n\n\n\n\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,8.1), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth =  0.4, linetype = 2)) +\n  theme(axis.ticks.x =  element_line(linewidth = 0.5, color=\"darkgrey\") , \n        axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1)) +\n  easy_remove_legend() +\n  ### the geom_text code below are created using the ggannotate package\n  geom_text(data = data.frame(x = 82, y = 7.8, \n    label = \"Alone\"), aes(x = x, y = y, label = label), size = 3, colour = \"#496899\") +\n  geom_text(data = data.frame(x = 82, y = 4.4, \n    label = \"With \\npartner\"), aes(x = x, y = y, label = label), size = 3,colour = \"#6b3d8d\") +\n  geom_text(data = data.frame(x = 80, y = 1.3, \n    label = \"With family\"),aes(x = x, y = y, label = label), size = 3, colour = \"#2b8465\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.7, \n    label = \"With children\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#986d39\") +\n geom_text(data = data.frame(x = 83.5, y = 0.5, \n    label = \"With friends\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#b03508\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.1, \n    label = \"With coworkers\"), aes(x = x, y = y, label = label), size = 2.5, colour = \"#883039\") +\n  labs(title = \"Who Americans spend their time with, by age, All people\", \n       subtitle = \"Measured in hours per day, based on averages from surveys in the United States \\nbetween 2010 and 2023\", \n       x = \"Age\", \n       y = \"Hours\",\n       caption = \"Data source: U.S. Bureau of Labor Statistics (2023). \\nNote: Activities such as sleeping, grooming, and personal care are not included in the data. \\nRelationships used to categorize people are not exhaustive and time spent with multiple people counts toward all \\n(e.g., attending a party with friends and partner counts toward both friends and partner)\") +\n  theme(plot.caption = element_text(hjust = 0)) # make the caption appear on the left"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-3-circular",
    "href": "charts/2025-03-31_challenge/index.html#day-3-circular",
    "title": "day 0 challenge",
    "section": "Day 3 circular",
    "text": "Day 3 circular\nWomen in government\n\nmy plotr code\n\n\n\n\n\n\nshare2024_regions %&gt;%\n  ggplot(aes(x = \"\", y = percent, fill = percent_women)) +\n  geom_col(colour = \"white\") +\n coord_polar(\"y\", start = 0) +\n  facet_wrap(~entity_name) +\n    scale_fill_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#6b3d8d\",  \"#986d39\" )) +\n    theme_void() +\n   easy_add_legend_title(\"Percent seats\") +\nlabs(title = \"Percent of countries by share of women in parliament in 2024, Regions\", \n       subtitle = \"Percent of seats in lower or single chamber of the legislature held by women\", \n       caption = \"Data source: V-Dem (2025) via OurWorldInData. \\nNote: Only countries with at least one legislative chamber included.\")"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-4-big-small",
    "href": "charts/2025-03-31_challenge/index.html#day-4-big-small",
    "title": "day 0 challenge",
    "section": "Day 4 big small",
    "text": "Day 4 big small\nTime spent in unpaid work\n\nmy plotr code\n\n\n\n\n\n\ndom_recent %&gt;%\n  ggplot(aes(x = male, y = female, colour = country)) +\n  geom_point(size = 2) +\n  theme_classic() +\n  easy_remove_legend() +\n  theme(panel.grid.major = element_line(color = \"lightgray\", linetype = 2)) +\n   scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                     expand = c(0,0), breaks = seq(0,25, 5), limits = c(0,30)) +\n   scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      expand = c(0,0), breaks = seq(0,12, 2), limits = c(0,14)) +\n  geom_abline(intercept = 0, slope = 1, colour = \"gray\", linetype = 2) +\n  geom_abline(intercept = 0, slope = 2, colour = \"gray\", linetype = 2) +\n  geom_abline(intercept = 0, slope = 4, colour = \"gray\", linetype = 2) +\n  geom_text(data = data.frame(x = 10, y = 3.5, label = \"Women and men spend \\nequal time\"), \n            mapping = aes(x = x, y = y, label = label), size = 2.5, inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 12.5, y = 28, label = \"Women spend 2x \\nmore time\"), \n            mapping = aes(x = x, y = y, label = label), size = 2.5,  inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 5, y = 26.8, label = \"Women spend 4x \\nmore time\"), \n            mapping = aes(x = x, y = y, label = label), size = 2.5, inherit.aes = FALSE) +\n  geom_text_repel(aes(label = country), size = 2.5, max.overlaps = 5) +\n  labs(title = \"Time women and men spend on unpaid care and domestic work, 2022\",\n       subtitle = \"The average share of each day that women and men aged 15 and older spend on unpaid care \\nand domestic work.\",\n       x = \"Men (% of 24 hour day)\", \n       y = \"Women (% of 24 hour day)\", \n       caption = \"Data source: UN Statistics Division and UN WOMEN.\nNote: Unpaid care and domestic work includes: food preparation,\ndishwashing, upkeep of a dwelling, laundry, ironing, gardening, caring\nfor pets, shopping, servicing and repair of personal and household\ngoods, childcare, and care of the sick, elderly or disabled household\nmembers, among others.\") +\n   theme(plot.caption = element_text(hjust = 0), \n         plot.subtitle = element_text(margin=margin(0,0,20,0))) +\n  geom_curve(data = data.frame(x = 5.5, y = 28.5, xend = 6.4, yend = 26),\n          mapping = aes(x = x, y = y, xend = xend, yend = yend), curvature = -0.515, \n          arrow = arrow(20L, unit(0.1, \"inches\"), \"last\", \"closed\"), alpha = 1, inherit.aes = FALSE) +\n  geom_curve(data = data.frame(x = 11.8, y = 28, xend = 12.2, yend = 26),\n          mapping = aes(x = x, y = y, xend = xend, yend = yend), curvature = 0.515, \n          arrow = arrow(20L, unit(0.1, \"inches\"), \"last\", \"closed\"), alpha = 1, inherit.aes = FALSE) +\n  geom_curve(data = data.frame(x = 8.8, y =4, xend = 8.2, yend = 7),\n          mapping = aes(x = x, y = y, xend = xend, yend = yend), curvature = -0.515, \n          arrow = arrow(20L, unit(0.1, \"inches\"), \"last\", \"closed\"), alpha = 1, inherit.aes = FALSE)"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-5-ranking",
    "href": "charts/2025-03-31_challenge/index.html#day-5-ranking",
    "title": "day 0 challenge",
    "section": "Day 5 ranking",
    "text": "Day 5 ranking\n\nR&Dspending\nR&Dresearchers\n\n\nmy plotr code\n\n\n\n\n\n\ntop5spend %&gt;%\nggplot(aes(year, rank, color = country)) +\n  geom_point(size = 5) +\n   geom_bump(size = 2, smooth = 8) +\n  scale_colour_manual(values = palette_takehe_plus) +\n  geom_text(data = top5spend %&gt;% filter(year == min(year)),\n            aes(x = year - .1, label = country), size = 3.5, hjust = 1) +\n  geom_text(data = top5spend %&gt;% filter(year == max(year)),\n            aes(x = year + .1, label = country), size = 3.5, hjust = 0) +\n    scale_y_reverse() +\n  scale_x_continuous(limits = c(2017.6, 2021.5),\n                     breaks = seq(2018, 2021, 1)) +\n  theme_minimal() +\n  easy_remove_legend() +\n  easy_remove_gridlines() +\n  labs(title = \"R&D spending percent of GDP: Top 5 countries\", \n       subtitle = \"includes basic research, applied research, and experimental development\", \n       y = \"Ranking\", x = \"Year\") +\n  geom_text(data = data.frame(x = 2019, y = 4.7, label = \"Switzerland\"),\nmapping = aes(x = x, y = y, label = label),\nsize = 3.7, colour = \"#D1C7B5\", inherit.aes = FALSE)"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-6-florence",
    "href": "charts/2025-03-31_challenge/index.html#day-6-florence",
    "title": "day 0 challenge",
    "section": "Day 6 florence",
    "text": "Day 6 florence\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-7-outliers",
    "href": "charts/2025-03-31_challenge/index.html#day-7-outliers",
    "title": "day 0 challenge",
    "section": "Day 7 outliers",
    "text": "Day 7 outliers\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-8-histogram",
    "href": "charts/2025-03-31_challenge/index.html#day-8-histogram",
    "title": "day 0 challenge",
    "section": "Day 8 histogram",
    "text": "Day 8 histogram\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code\n\n\n\n\n:::"
  },
  {
    "objectID": "charts/2025-04-01_fractions/index.html",
    "href": "charts/2025-04-01_fractions/index.html",
    "title": "day 1 fractions",
    "section": "",
    "text": "This plot from Our World in Data illustrates the proportion of people who are willing to donate 1% of their income to climate change efforts as a function of people’s estimate of how many people in their country would be willing to donate.\nAs it turns out, people have a rather dim view of the likelihood that others would commit to supporting climate action. Lets see if we can reproduce the chart using ggplot.\n\n\n\nload packages\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(owidapi)\nlibrary(scales)\nlibrary(ggeasy)\nlibrary(ggrepel)\nlibrary(plotly)\n\ncatalog &lt;- owid_get_catalog()\n\n\n\nread in the data\nHere I am using the owidapi package to read in the data and reordering/renaming some variables before sorting the data by country and year.\n\nwillingness &lt;- owid_get(\"willingness-climate-action\") %&gt;%\n  select(entity_name, entity_id, owid_region, year, \n         prediction_others_willingness = willingness_contribute_1pct_climate_others, \n         self_willingness = willingness_contribute_pct_climate) %&gt;%\n   arrange(entity_id, year)\n\n\nglimpse(willingness)\n\nRows: 397\nColumns: 6\n$ entity_name                   &lt;chr&gt; \"Democratic Republic of Vietnam\", \"Duchy…\n$ entity_id                     &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", …\n$ owid_region                   &lt;chr&gt; \"Asia\", \"Europe\", \"Europe\", \"North Ameri…\n$ year                          &lt;int&gt; 2023, 2023, 2023, 2023, 2023, 2023, 2023…\n$ prediction_others_willingness &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ self_willingness              &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n\n\n\n\nclean up the data\nLooks like the plot only includes 2024 data, so lets filter first.\n\nwillingness2024 &lt;- willingness %&gt;%\n  filter(year == 2024) \n \n\nglimpse(willingness2024)\n\nRows: 126\nColumns: 6\n$ entity_name                   &lt;chr&gt; \"Afghanistan\", \"Albania\", \"United Arab E…\n$ entity_id                     &lt;chr&gt; \"AFG\", \"ALB\", \"ARE\", \"ARG\", \"ARM\", \"AUS\"…\n$ owid_region                   &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", …\n$ year                          &lt;int&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024…\n$ prediction_others_willingness &lt;dbl&gt; 40.5, 43.8, 53.9, 38.1, 40.7, 38.6, 37.9…\n$ self_willingness              &lt;dbl&gt; 82.0, 71.3, 81.7, 62.2, 75.4, 56.1, 72.7…\n\n\nUnfortunately in filtering out the 2023 data, I have also lost information about the owid region, which is used in colouring the dots in the plot. I need to go back to the dataset that has regions for 2023 and have them propogate into the 2024 rows as well.\nThis chunk groups the data by country and then mutates a new column to contain new region values. It looks just at 2023 rows and pulls the first value of region from those. Then we can filter for just 2024 values.\n\nwillingness2024 &lt;- willingness %&gt;%\n  group_by(entity_name) %&gt;%\n  mutate(region = first(owid_region[year == 2023])) %&gt;%\n  select(starts_with(\"entity\"), region, year, ends_with(\"willingness\")) %&gt;%\n  filter(year == 2024) \n \nglimpse(willingness2024)\n\nRows: 126\nColumns: 6\nGroups: entity_name [126]\n$ entity_name                   &lt;chr&gt; \"Afghanistan\", \"Albania\", \"United Arab E…\n$ entity_id                     &lt;chr&gt; \"AFG\", \"ALB\", \"ARE\", \"ARG\", \"ARM\", \"AUS\"…\n$ region                        &lt;chr&gt; \"Asia\", \"Europe\", \"Asia\", \"South America…\n$ year                          &lt;int&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024…\n$ prediction_others_willingness &lt;dbl&gt; 40.5, 43.8, 53.9, 38.1, 40.7, 38.6, 37.9…\n$ self_willingness              &lt;dbl&gt; 82.0, 71.3, 81.7, 62.2, 75.4, 56.1, 72.7…\n\n\n\n\nmake a basic plot\n\nwillingness2024 %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness)) +\n  geom_point() +\n  scale_y_continuous(limits = c(0,100)) +\n    scale_x_continuous(limits = c(0,100)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\") \n\n\n\n\n\n\n\n\nOK, basic plot success… things that I need to change\n\naxis values in 20% increments with %\ntheme needs to be white background with dotted gridlines on 20% values\ndiagonal dotted line\ncolour points by region\ninclude text of selection of countries\ncaption re data source\ntitle and subtitle\nplotly interactivity\n\n\n\ngridlines and axes\nHere I am using the expand and breaks arguments within scale_y_continuous and scale_x_continuous to make the axis start at 0,0 and have 20% increments. I get % labels on each access using the percent_format() function from the scales package (accuracy = 1 tells R I want it to display whole numbers and scale = 1 tells R my numbers are already percentages and don’t need to be multiplied by 100).\nI removed the minor gridlines using easy_remove_gridlines() from the ggeasy package. I also added a diagonal line usinggeom_abline().\n\nwillingness2024 %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness)) +\n  geom_point() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n    scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                       limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\") +\n  theme_bw()  +\n  easy_remove_gridlines(axis = \"both\", minor = TRUE, major = FALSE) +\n  geom_abline(\n    slope = 1, \n    intercept = 0, \n    color = \"grey\", \n    linetype = \"dotted\")\n\n\n\n\n\n\n\n\n\n\ncolours and text\nAdding colour by region makes me realise that there is a row that entity_name == World, which doesn’t have a region. I need to filtered the World out to avoid an NA category.\nI want to use the same colours as the OWID plot. The ColorZilla web extension allows you to use a dropper to get the specific # codes for each colour on any plot on the internet- handy!\nI have used scale_colour_manual() to set the colours and added a title and subtitle using labs and removed the legend title using a function from the ggeasy package. I have added some country labels, while trying to avoid overlapping the point using the geom_text_repel() function from the ggrepel package. It does give me a warning that there are too many overlapping points though.\n\nwillingness2024 %&gt;%\n  filter(entity_name != \"World\") %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness, colour = region)) +\n  geom_point() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n    scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                       limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\", \n       title = \"People underestimate others' willingness to take climate action\", \n       subtitle = \"Participants were asked if they would contribute 1% of their income to tackle \\nclimate change. \\nThe share that answered 'yes' is shown on the horizontal axis. \\nThe share of the population in their country that people think would be willing \\nis shown on the vertical axis.\") +\n  theme_bw()  +\n  easy_remove_gridlines(axis = \"both\", minor = TRUE, major = FALSE) +\n  geom_abline(\n    slope = 1, \n    intercept = 0, \n    color = \"grey\", \n    linetype = \"dotted\") +\n  scale_colour_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#883039\")) +\n  easy_remove_legend_title() +\n  geom_text_repel(aes(label = entity_name), size = 3, max.overlaps = 20)\n\n\n\n\n\n\n\n\n\n\ninteractivity\nThe plotly packages allows for much of the same kind of interactivity that the grapher tool allows on Our World in Data. Here I have added an extra text argument to the ggplot aes to make the hover option display the country associated with each point, as well as the variables that were mapped. By assigning the ggplot to an object and then using the ggplotly() function, we can produce an interactive plot.\n\nplot &lt;- willingness2024 %&gt;%\n  filter(entity_name != \"World\") %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness, \n             colour = region, text = paste(\"country:\", entity_name))) +\n  geom_point() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n    scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                       limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\", \n       title = \"People underestimate others' willingness to take climate action\", \n       subtitle = \"Participants were asked if they would contribute 1% of their income to tackle climate change. \\nThe share that answered 'yes' is shown on the horizontal axis. The share of the population \\nin their country that people think would be willing is shown on the vertical axis.\") +\n  theme_bw()  +\n  theme(panel.grid.minor = element_blank()) +\n  geom_abline(\n    slope = 1, \n    intercept = 0, \n    color = \"grey\", \n    linetype = \"dotted\") +\n  scale_colour_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#883039\")) +\n  easy_remove_legend_title() \n\ninteractive_plot &lt;- ggplotly(plot)\n\ninteractive_plot"
  },
  {
    "objectID": "charts/2025-04-04_bigsmall/index.html",
    "href": "charts/2025-04-04_bigsmall/index.html",
    "title": "day 4 big small",
    "section": "",
    "text": "This plot illustrates the disproportionate amount of time that women across the world spend doing unpaid care and domestic work relative to men. Only Belgium comes anywhere near close to equal time spent by men and women.\nI am particularly interested in whether there has been any shift in this ratio in the last 20 years, so my goal is to reproduce this plot in ggplot using the most recent data for each country and then look at change over time.\n\n\n\nload packages\n\nlibrary(tidyverse)\nlibrary(owidapi)\nlibrary(scales)\nlibrary(ggeasy)\nlibrary(ggrepel)\nlibrary(plotly)\nlibrary(janitor)\n\ncatalog &lt;- owid_get_catalog()\n\n\nread in the data\n\ndom &lt;- owid_get(\"time-spent-in-domestic-work-female-vs-male\") \n\n\n\nclean it up\nHere I am renaming some unweildy variable names, filtering the data to include only years since 2000, and getting rid of NA values. I then filter that dataframe to only include the most recent data year for each country.\n\ndom_clean &lt;- dom %&gt;%\n  rename(country = \"entity_name\", \n         female = \"x_5_4_1__sl_dom_tspd__15_years_old_and_over__all_areas__female\", \n         male = \"x_5_4_1__sl_dom_tspd__15_years_old_and_over__all_areas__male\") %&gt;%\n  filter(year &gt; 2000) %&gt;%\n  filter(!is.na(female)) \n\n\ndom_recent &lt;- dom_clean %&gt;%\n  group_by(country) %&gt;%\n  filter(year == max(year))\n\n\n\nplot\n\ndom_recent %&gt;%\n  ggplot(aes(x = male, y = female)) +\n  geom_point() \n\n\n\n\n\n\n\n\nBasic plot check! Things I need to change…\n\nwhite background with dotted gridlines\ncoloured points\nfix scale on axis and % labels\nadd diagonal lines\nadd labels to diagonal lines and points\nadd titles, subtitles, x and y\n\n\n\ntheme, axis, diagonal lines\ntheme_classic does a good job of getting rid of the grey background and adding dark axis lines. I add gridlines and with theme(panel.grid.major() and fix the scale on each axis by setting breaks and limits. I colour the points by country here (because the dataset is missing region information) and use easy_remove_legend() from ggeasy to hide the legend. I add diagonal lines representing equal, twice, and four times using geom_abline() with different slopes.\n\ndom_recent %&gt;%\n  ggplot(aes(x = male, y = female, colour = country)) +\n  geom_point(size = 2) +\n  theme_classic() +\n  easy_remove_legend() +\n  theme(panel.grid.major = element_line(color = \"lightgray\", linetype = 2)) +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                     expand = c(0,0), breaks = seq(0,25, 5), limits = c(0,30)) +\n   scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      expand = c(0,0), breaks = seq(0,12, 2), limits = c(0,14)) +\n  geom_abline(intercept = 0, slope = 1, colour = \"gray\", linetype = 2) +\n  geom_abline(intercept = 0, slope = 2, colour = \"gray\", linetype = 2) +\n  geom_abline(intercept = 0, slope = 4, colour = \"gray\", linetype = 2) \n\n\n\n\n\n\n\n\n\n\nannonations\nThe ggannotate package is super useful here. I didn’t realise that there was an angle option in the Shiny app popup that helps you place your annotation. Here I have used ggannotate to place labels on the geom_abline() lines, and geom_text_repel() to label each point with a country label.\n\n\n\n\n\n\nNote\n\n\n\nIt is SUPER fiddly to get the x, y position and angle of these labels just right and then… when you render the doc they can look slightly different to the inline output and then… when you export via ggsave they can look slight different again. I decide below it might not be worth the effort!\n\n\n\ndom_recent %&gt;%\n  ggplot(aes(x = male, y = female, colour = country)) +\n  geom_point(size = 2) +\n  theme_classic() +\n  easy_remove_legend() +\n  theme(panel.grid.major = element_line(color = \"lightgray\", linetype = 2)) +\n   scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                     expand = c(0,0), breaks = seq(0,25, 5), limits = c(0,30)) +\n   scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      expand = c(0,0), breaks = seq(0,12, 2), limits = c(0,14)) +\n  geom_abline(intercept = 0, slope = 1, colour = \"gray\", linetype = 2) +\n  geom_abline(intercept = 0, slope = 2, colour = \"gray\", linetype = 2) +\n  geom_abline(intercept = 0, slope = 4, colour = \"gray\", linetype = 2) +\n  \n  geom_text(data = data.frame(x = 12, y = 13, label = \"Women and men spend equal time\"), \n            mapping = aes(x = x, y = y, label = label), size = 3, angle = 16L, inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 12, y = 25, label = \"Women spend 2x more time\"), \n            mapping = aes(x = x, y = y, label = label), size = 3, angle = 29L, inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 6.2, y = 25.8, label = \"Women spend 4 x more time\"), \n            mapping = aes(x = x, y = y, label = label), size = 3, angle = 48L, inherit.aes = FALSE) +\n  geom_text_repel(aes(label = country), size = 2.5, max.overlaps = 10)\n\n\n\n\n\n\n\n\n\n\ntitles and captions\nAdding a title and subtitle, messed with my line annotations and I am not really sure why. I thought I had fixed the problem by adding some margin below the subtitle, making the font on the annotations smaller, and adjusting the xy position/angle of each label, but then got annoyed the that rendered angle didn’t look the same as my inline output.\nI decided that it wasn’t important for the text to sit along the line and decided to add arrows instead! I also set a seed here after realising the everytime your run the code the geom_text_repel() positions the labels slightly differently if you don’t have a seed.\n\nseed = 44\n\np &lt;- dom_recent %&gt;%\n  ggplot(aes(x = male, y = female, colour = country)) +\n  geom_point(size = 2) +\n  theme_classic() +\n  easy_remove_legend() +\n  theme(panel.grid.major = element_line(color = \"lightgray\", linetype = 2)) +\n   scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                     expand = c(0,0), breaks = seq(0,25, 5), limits = c(0,30)) +\n   scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      expand = c(0,0), breaks = seq(0,12, 2), limits = c(0,14)) +\n  geom_abline(intercept = 0, slope = 1, colour = \"gray\", linetype = 2) +\n  geom_abline(intercept = 0, slope = 2, colour = \"gray\", linetype = 2) +\n  geom_abline(intercept = 0, slope = 4, colour = \"gray\", linetype = 2) +\n  geom_text(data = data.frame(x = 10, y = 3.5, label = \"Women and men spend \\nequal time\"), \n            mapping = aes(x = x, y = y, label = label), size = 2.5, inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 12.5, y = 28, label = \"Women spend 2x \\nmore time\"), \n            mapping = aes(x = x, y = y, label = label), size = 2.5,  inherit.aes = FALSE) +\n  geom_text(data = data.frame(x = 5, y = 26.8, label = \"Women spend 4x \\nmore time\"), \n            mapping = aes(x = x, y = y, label = label), size = 2.5, inherit.aes = FALSE) +\n  geom_text_repel(aes(label = country), size = 2.5, max.overlaps = 5) +\n  labs(title = \"Time women and men spend on unpaid care and domestic work, 2022\",\n       subtitle = \"The average share of each day that women and men aged 15 and older spend on unpaid care \\nand domestic work.\",\n       x = \"Men (% of 24 hour day)\", \n       y = \"Women (% of 24 hour day)\", \n       caption = \"Data source: UN Statistics Division and UN WOMEN.\nNote: Unpaid care and domestic work includes: food preparation,\ndishwashing, upkeep of a dwelling, laundry, ironing, gardening, caring\nfor pets, shopping, servicing and repair of personal and household\ngoods, childcare, and care of the sick, elderly or disabled household\nmembers, among others.\") +\n   theme(plot.caption = element_text(hjust = 0), \n         plot.subtitle = element_text(margin=margin(0,0,20,0))) +\n  geom_curve(data = data.frame(x = 5.5, y = 28.5, xend = 6.4, yend = 26),\n          mapping = aes(x = x, y = y, xend = xend, yend = yend), curvature = -0.515, \n          arrow = arrow(20L, unit(0.1, \"inches\"), \"last\", \"closed\"), alpha = 1, inherit.aes = FALSE) +\n  geom_curve(data = data.frame(x = 11.8, y = 28, xend = 12.2, yend = 26),\n          mapping = aes(x = x, y = y, xend = xend, yend = yend), curvature = 0.515, \n          arrow = arrow(20L, unit(0.1, \"inches\"), \"last\", \"closed\"), alpha = 1, inherit.aes = FALSE) +\n  geom_curve(data = data.frame(x = 8.8, y =4, xend = 8.2, yend = 7),\n          mapping = aes(x = x, y = y, xend = xend, yend = yend), curvature = -0.515, \n          arrow = arrow(20L, unit(0.1, \"inches\"), \"last\", \"closed\"), alpha = 1, inherit.aes = FALSE) \np\n\n\n\n\n\n\n\n\n\n\ninteractivity\nIt is still miraculous to me that you can get an interactive plot like this in a single line of code. plotly for the win!\n\n\n\n\n\n\nNote\n\n\n\nNote I have ignored a lot of red warning messages from plotly here about how it doesn’t like geom_text_repel() or geom_curve()\n\n\n\nggplotly(p)\n\n\n\n\n\n\n\nbonus\nHow has the ratio of time that women and men spend in unpaid domestic labour changed over time? Given the theme today is big/small, I am going to choose the countries that have the biggest vs smallest discrepancy.\nI am dropping extra columns and computing a new variable that is the difference between the percent of time that women and men spend in unpaid domestic labour for each country and year. I am arranging these scores in descending order and then looking at the top 3 (head) and the bottom 3 (tail).\n\ndifference &lt;-  dom_clean %&gt;%\n  select(-entity_id, -population_historical, -owid_region) %&gt;%\n  rowwise() %&gt;%\n  mutate(difference = female - male) %&gt;%\n  arrange(desc(difference)) \n\nhead(difference, 3)\n\n# A tibble: 3 × 5\n# Rowwise: \n  country  year female  male difference\n  &lt;chr&gt;   &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n1 Mexico   2009   31.0 10.4        20.7\n2 Armenia  2004   24.0  4.58       19.5\n3 Tunisia  2006   21.9  2.71       19.2\n\ntail(difference, 3)\n\n# A tibble: 3 × 5\n# Rowwise: \n  country   year female  male difference\n  &lt;chr&gt;    &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n1 Norway    2011  15.3  12.3        2.98\n2 Colombia  2013   4.22  2.03       2.19\n3 Belgium   2013   2.43  2.04       0.39\n\n\nI am filtering the data to only include these top and bottom countries. Unfortunately we don’t have data for several years in all of these countries, so lets plot Columbia and Mexico for illustration.\n\ntopbottom &lt;- c(\"Norway\", \"Colombia\", \"Belgium\", \"Mexico\", \"Armenia\", \"Tunisia\")\n\ntb &lt;- difference %&gt;%\n  filter(country %in% topbottom) %&gt;%\n  arrange(country, year)\n\ntb %&gt;%\n  tabyl(country)\n\n  country n    percent\n  Armenia 2 0.18181818\n  Belgium 1 0.09090909\n Colombia 3 0.27272727\n   Mexico 3 0.27272727\n   Norway 1 0.09090909\n  Tunisia 1 0.09090909\n\n\n\n\nplot\nIt is interesting that the difference in the amount of time that men and women engage in unpaid domestic labour has come down in Mexico (one of the most discrepant countries in 2009) but become more different in Colombia, who in 2013 had one of the smallest differences between men and women.\n\ntb %&gt;%\n  filter(country %in% c(\"Mexico\", \"Colombia\")) %&gt;%\n  ggplot(aes(x = year, y = difference, colour = country)) +\n  geom_point() +\ngeom_line() +\n  facet_wrap(~country) +\n  easy_remove_legend() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                     expand = c(0,0), breaks = seq(0,25, 5), limits = c(0,25)) +\n  scale_x_continuous(breaks = seq(2009,2021, 2)) +\n  theme_classic() +\n  labs(y = \"Percent difference in women and men\", y = \"Year\")"
  },
  {
    "objectID": "charts/2025-04-05_ranking/index.html",
    "href": "charts/2025-04-05_ranking/index.html",
    "title": "day 5 ranking",
    "section": "",
    "text": "load packages\n\nlibrary(tidyverse)\nlibrary(Hmisc) # for %nin%\nlibrary(janitor)\nlibrary(owidapi)\nlibrary(ggbump)\nlibrary(ggeasy)\nlibrary(patchwork)\n\nThese plots from Our World in Data caught my eye this week given all that is going on in the USA with layoffs and funding cuts (R&Dspending ; R&Dresearchers).\nThey illustrate the amount of money that countries spend on research and development as a percent of GDP and the number of people that work in R&D as a function of population and GDP. The theme today is ranking, so I wonder whether I can look at where the USA ranks relative to other countries on these metrics.\n\n\n\n\n\nread in the data\nHere I am reading the data and renaming variables. I am also filtering out some regions that had appeared in the country variable.\n\n# read spend data\n\nspend &lt;- read_csv(\"https://ourworldindata.org/grapher/research-spending-gdp.csv?v=1&csvType=full&useColumnShortNames=true\") %&gt;%\n  clean_names %&gt;%\n  select(country = entity, year, rdgdp = gb_xpd_rsdv_gd_zs) \n\nremove &lt;- c(\"North America (WB)\"    , \"East Asia and Pacific (WB)\", \"High-income countries\", \"World\", \"European Union (27)\", \"Europe and Central Asia (WB)\", \"South Asia (WB)\")\n\nspend &lt;-  spend %&gt;%\n  filter(country %nin% remove)\n\n# read people data\n\npeople &lt;- read_csv(\"https://ourworldindata.org/grapher/researchers-in-rd-per-million-people-vs-gdp-pc.csv?v=1&csvType=full&useColumnShortNames=true\") %&gt;%\n  clean_names %&gt;%\n  select(country = entity, year, researchers_per_mill = sp_pop_scie_rd_p6, gdp_per_cap = ny_gdp_pcap_pp_kd) %&gt;%\n  filter(!is.na(researchers_per_mill)) \n\n\n\nget ranks\nI am most interested in the top5 ranked countries in terms of the percent of GDP they spend on R&D. I group by year and create a new variable that is the rank of the researchers as a function of gdp. I remember to ungroup() the data before arranging by year and rank.\nThen I make a dataframe with only the top 5 countries by rank for each year and filter the data to only include 2018-2021, and repeat the process for the people data.\n\n# get spend ranks\nspend_rank &lt;- spend %&gt;%\n  group_by(year) %&gt;%\n  mutate(rank = rank(-rdgdp, ties.method = \"random\")) %&gt;% \n  ungroup() %&gt;%\n  arrange(-year, rank)\n\ntop5spend &lt;- spend_rank %&gt;%\n  filter(rank &lt;=5) %&gt;%\n  filter(year &gt;= 2018) %&gt;%\n  filter(year &lt; 2022)\n\n# get people ranks\n\npeople_rank &lt;- people %&gt;%\n  group_by(year) %&gt;%\n  mutate(rank = rank(-researchers_per_mill, ties.method = \"random\")) %&gt;% \n  ungroup() %&gt;%\n  arrange(-year, rank)\n\ntop5people &lt;- people_rank %&gt;%\n  filter(rank &lt;=5) %&gt;%\n  filter(year &gt;= 2018) %&gt;%\n  filter(year &lt; 2022)\n\n\n\nbump plots\nI hadn’t really heard of a “bump” plot before I looked at the RGraphGallery for ranking data inspiration. The ggbump package makes it really easy to plot rankings in this way.\n\nspend\n\ntop5spend %&gt;%\nggplot(aes(year, rank, color = country)) +\n  geom_point(size = 5) +\n   geom_bump(size = 2, smooth = 8) +\n  geom_text(data = top5spend %&gt;% filter(year == min(year)),\n            aes(x = year - .1, label = country), size = 3.5, hjust = 1) +\n  geom_text(data = top5spend %&gt;% filter(year == max(year)),\n            aes(x = year + .1, label = country), size = 3.5, hjust = 0) +\n    scale_y_reverse() +\n  scale_x_continuous(limits = c(2017.6, 2021.5),\n                     breaks = seq(2018, 2021, 1)) +\n  theme_minimal() +\n  easy_remove_legend() +\n  easy_remove_gridlines()  \n\n\n\n\n\n\n\n\nIt is interesting that Israel and South Korea are clearly in the lead when it comes to investment in R&D as a percent of GDP. The United States only features in the top 5 since 2020.\n\n\npeople\nWhat about the R&D workforce? How many researchers are working in each of these countries?\nI expected more overlap between the number of people working the R&D per million and the GDP spend. Israel and the USA are nowhere to be seen. South Korea comes up on top, and Scandinavian countries are really highly represented.\n\ntop5people %&gt;%\nggplot(aes(year, rank, color = country)) +\n  geom_point(size = 5) +\n   geom_bump(size = 2, smooth = 8) +\n  geom_text(data = top5people %&gt;% filter(year == min(year)),\n            aes(x = year - .1, label = country), size = 3.5, hjust = 1) +\n  geom_text(data = top5people %&gt;% filter(year == max(year)),\n            aes(x = year + .1, label = country), size = 3.5, hjust = 0) +\n    scale_y_reverse() +\n  scale_x_continuous(limits = c(2017.6, 2021.5),\n                     breaks = seq(2018, 2021, 1)) +\n  theme_minimal() +\n  easy_remove_legend() +\n  easy_remove_gridlines() \n\n\n\n\n\n\n\n\nOK- adapting the code from the ggbump package vignette gets me most of the way there… but there are a couple things I want to change.\n\nthe colour palette (I need to make the colour associated with each country consistent across this and the people plot below)\ntitles, axis labels\n\n\n\n\ncolours\nI would like to present these two plots together, so need to make the colours associated with each country distinct, but the same across plots (i.e. South Korea and Sweden need to be associated with the same colour in both plots).\nAfter much fiddling with scale_colour_manual(), I realised that a colour palette was probably the best way to go. The manu package has lovely palettes inspired by New Zealand birds.\nI need one palette that has 8 colours for the spend plot and another that has 6 colours for the people plot. I decided to use the 6 colour kereru palette for the people plot and to add a couple of those colours to the takehe palette (plus an extra blue), to make up the 8 colours needed for the spend plot.\nTo ensure that the order of the countries / colours lined up, I made country a factor and checked that the levels of that factor matched the palette.\n\ntop5spend$country &lt;- as.factor(top5spend$country)\n\nlevels(top5spend$country)\n\n[1] \"Belgium\"       \"Germany\"       \"Israel\"        \"Japan\"        \n[5] \"South Korea\"   \"Sweden\"        \"Switzerland\"   \"United States\"\n\npalette_takehe_plus &lt;- c(\"#DD3C51\", \"#313657\", \"#1F6683\", \"#6C90B9\", \"#4d5f8e\",\"#A092B7\",\"#D1C7B5\", \"#85BEDC\")\n\n\ntop5people$country &lt;- as.factor(top5people$country)\n\nlevels(top5people$country)\n\n[1] \"Denmark\"     \"Finland\"     \"Norway\"      \"Singapore\"   \"South Korea\"\n[6] \"Sweden\"     \n\npalette_kereru &lt;- c(\"#325756\", \"#7d9fc2\", \"#C582B2\", \"#51806a\", \"#4d5f8e\", \"#A092B7\")\n\n\ns &lt;- top5spend %&gt;%\nggplot(aes(year, rank, color = country)) +\n  geom_point(size = 5) +\n   geom_bump(size = 2, smooth = 8) +\n  scale_colour_manual(values = palette_takehe_plus) +\n  geom_text(data = top5spend %&gt;% filter(year == min(year)),\n            aes(x = year - .1, label = country), size = 3.5, hjust = 1) +\n  geom_text(data = top5spend %&gt;% filter(year == max(year)),\n            aes(x = year + .1, label = country), size = 3.5, hjust = 0) +\n    scale_y_reverse() +\n  scale_x_continuous(limits = c(2017.6, 2021.5),\n                     breaks = seq(2018, 2021, 1)) +\n  theme_minimal() +\n  easy_remove_legend() +\n  easy_remove_gridlines() +\n  labs(title = \"R&D spending percent of GDP: Top 5 countries\", \n       subtitle = \"includes basic research, applied research, and experimental development\", \n       y = \"Ranking\", x = \"Year\") +\n  geom_text(data = data.frame(x = 2019, y = 4.7, label = \"Switzerland\"),\nmapping = aes(x = x, y = y, label = label),\nsize = 3.7, colour = \"#D1C7B5\", inherit.aes = FALSE)\n\ns\n\n\n\n\n\n\n\np &lt;- top5people %&gt;%\nggplot(aes(year, rank, color = country)) +\n  geom_point(size = 5) +\n   geom_bump(size = 2, smooth = 8) +\n   scale_colour_manual(values = palette_kereru) +\n  geom_text(data = top5people %&gt;% filter(year == min(year)),\n            aes(x = year - .1, label = country), size = 3.5, hjust = 1) +\n  geom_text(data = top5people %&gt;% filter(year == max(year)),\n            aes(x = year + .1, label = country), size = 3.5, hjust = 0) +\n    scale_y_reverse() +\n  scale_x_continuous(limits = c(2017.6, 2021.5),\n                     breaks = seq(2018, 2021, 1)) +\n  theme_minimal() +\n  easy_remove_legend() +\n  easy_remove_gridlines() +\n  labs(title = \"R&D researchers per million people: Top 5 countries\", \n       subtitle = \"Professionals conceiving or creating new knowledge, products, processes, methods, or systems\", \n       y = \"Ranking\", x = \"Year\") \n\np\n\n\n\n\n\n\n\n\n\n\npatchwork\nThe patchwork package makes it super easy to combine different ggplots into a single output. Here I am using the / operator to combine plots vertically (if you wanted them side by side you would use the + operator).\n\ns / p"
  },
  {
    "objectID": "charts/2025-04-02_slope/index.html",
    "href": "charts/2025-04-02_slope/index.html",
    "title": "day 2 slope",
    "section": "",
    "text": "This plot from Our World in Data illustrates the amount of time that we spend with others and how that changes with age. The slope of line plotting the amount of time that people spend alone is pretty terrifying. Lets see if we can reproduce that plot using ggplot.\n\n\n\nload packages\n\nlibrary(tidyverse)\nlibrary(owidapi)\nlibrary(scales)\nlibrary(ggeasy)\nlibrary(ggannotate)\n\n# remotes::install_github(\"mattcowgill/ggannotate\")\n\ncatalog &lt;- owid_get_catalog()\n\n\n\nread in the data\nHere I am reading the data using the owidapi package and selecting and renaming columns within the same line of code. I also want to make the data long so that the category information appears in a single column and the hours values in another.\nI know that colours are often easier to deal with if we turn character variables into factors so that we can set the order. Here I use fct_relevel() to order the categories so that I can easily line up which colour is associated with each.\n\ntime &lt;- owid_get(\"time-spent-with-relationships-by-age-us\") %&gt;%\n  select(group = entity_name, age = year, \n         alone = t__who_category_alone, friend = t__who_category_friend, \n         children = t__who_category_children, family = t__who_category_family, \n         partner = t__who_category_partner, coworker = t__who_category_co_worker) %&gt;%\n  pivot_longer(names_to = \"category\", values_to = \"hours\", alone:coworker)\n\n\ntime$category &lt;- fct_relevel(time$category, c(\"alone\", \"partner\", \"family\", \"children\", \"friend\", \"coworker\"))\n\nlevels(time$category) #check levels\n\n[1] \"alone\"    \"partner\"  \"family\"   \"children\" \"friend\"   \"coworker\"\n\nglimpse(time)\n\nRows: 1,206\nColumns: 4\n$ group    &lt;chr&gt; \"All people\", \"All people\", \"All people\", \"All people\", \"All …\n$ age      &lt;int&gt; 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 1…\n$ category &lt;fct&gt; alone, friend, children, family, partner, coworker, alone, fr…\n$ hours    &lt;dbl&gt; 3.629829200, 1.584973700, 0.363883400, 4.324233500, 0.0000000…\n\n\n\n\nmake basic plot\nThe dataset contains time use data for Male and Female separate, but lets start with a plot of All people.\n\ntime %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point() + \n  geom_line() \n\n\n\n\n\n\n\n\nBasic plot… check! Here is a list of things I would like to change…\n\ntheme and colours\nadd horizontal gridlines\nfilter out data point more than 80\nstart x axis at 15, 30 then in increments of 10\ny axis add h to numbers\nadd group annotations rather than legend\n\n\n\ntheme and colours\nI started by filtering out data with age values greater than 80. I used the ColorZilla web extension to get the # codes for the colours in the Our World in Data plot and scale_colour_manual() to set the colours.\nI fixed the y axis using scale_y_continuous() breaks and got most of the way there with theme_minimal(). The easy_remove_gridlines() function from ggeasy makes it easy to control which gridlines you want to display. Here I want to remove both major and minor verticial lines but keep the major horizontal lines. I want the gridlines to be dotted and use the theme(panel.grid = element_line() to achieve that.\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  scale_y_continuous(expand = c(0,0), breaks = seq(0,8,1)) +\n  theme_minimal() +\n  easy_remove_gridlines(axis = \"x\", major = TRUE, minor = TRUE) +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth = 0.4, linetype = 2))\n\n\n\n\n\n\n\n\n\n\naxes\nNow theme_minimal() removes the x and y axis lines and ticks. I want to add the line/ticks back in on just the x axis so use theme(axis.line.x = element_line()and theme(axis.ticks.x = element_line().\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,8.1), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth = 0.4, linetype = 2)) +\n  theme(axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1), \n        axis.ticks.x = element_line(linewidth = 0.5, color=\"darkgrey\")\n        )\n\n\n\n\n\n\n\n\n\n\nannotations\nThe easy_remove_legend() function from the ggeasy package makes it easy to get rid of a legend; getting annotations on the end of the each line is a bit tricker. I’m sure there is a simpler way, but the ggannotate package by Matt Cowgill pulls up a shiny panel that allows you to place annotations where you want them and then copy the geom_text() code into your chunk.\n\n  time %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,8.1), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth = 0.4, linetype = 2)) +\n  theme(axis.ticks.x =   element_line(linewidth = 0.5, color=\"darkgrey\") , \n        axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1)) +\n  easy_remove_legend() +\n  geom_text(data = data.frame(x = 82, y = 8, \n    label = \"Alone\"), aes(x = x, y = y, label = label), size = 3, colour = \"#496899\") +\n  geom_text(data = data.frame(x = 82, y = 4.4, \n    label = \"With \\npartner\"), aes(x = x, y = y, label = label), size = 3,colour = \"#6b3d8d\") +\n  geom_text(data = data.frame(x = 80, y = 1.3, \n    label = \"With family\"),aes(x = x, y = y, label = label), size = 3, colour = \"#2b8465\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.7, \n    label = \"With children\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#986d39\") +\n geom_text(data = data.frame(x = 83.5, y = 0.5, \n    label = \"With friends\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#b03508\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.1, \n    label = \"With coworkers\"), aes(x = x, y = y, label = label), size = 2.5, colour = \"#883039\")\n\n\n\n\n\n\n\n\n\n\ntitles and captions\nFinishing touches… title, subtitle and caption. The theme(plot.caption = element_text(hjust = 0)) makes the caption appear on the left side of the plot.\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,8.1), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth =  0.4, linetype = 2)) +\n  theme(axis.ticks.x =  element_line(linewidth = 0.5, color=\"darkgrey\") , \n        axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1)) +\n  easy_remove_legend() +\n  ### the geom_text code below are created using the ggannotate package\n  geom_text(data = data.frame(x = 82, y = 7.8, \n    label = \"Alone\"), aes(x = x, y = y, label = label), size = 3, colour = \"#496899\") +\n  geom_text(data = data.frame(x = 82, y = 4.4, \n    label = \"With \\npartner\"), aes(x = x, y = y, label = label), size = 3,colour = \"#6b3d8d\") +\n  geom_text(data = data.frame(x = 80, y = 1.3, \n    label = \"With family\"),aes(x = x, y = y, label = label), size = 3, colour = \"#2b8465\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.7, \n    label = \"With children\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#986d39\") +\n geom_text(data = data.frame(x = 83.5, y = 0.5, \n    label = \"With friends\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#b03508\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.1, \n    label = \"With coworkers\"), aes(x = x, y = y, label = label), size = 2.5, colour = \"#883039\") +\n  labs(title = \"Who Americans spend their time with, by age, All people\", \n       subtitle = \"Measured in hours per day, based on averages from surveys in the United States \\nbetween 2010 and 2023\", \n       x = \"Age\", \n       y = \"Hours\",\n       caption = \"Data source: U.S. Bureau of Labor Statistics (2023). \\nNote: Activities such as sleeping, grooming, and personal care are not included in the data. \\nRelationships used to categorize people are not exhaustive and time spent with multiple people counts toward all \\n(e.g., attending a party with friends and partner counts toward both friends and partner)\") +\n  theme(plot.caption = element_text(hjust = 0)) # make the caption appear on the left\n\n\n\n\n\n\n\n\n\n\nbonus\nAt this point I am wondering whether who people spend their time with differs for men and women. Here I have changed the filter to include both Men and Women and added a facet_wrap(~group) to plot the gender data separately.\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group %in% c(\"Men\", \"Women\")) %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = .6) + \n  geom_line() +\n  facet_wrap(~ group) +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,10), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth =  0.4, linetype = 2)) +\n  theme(axis.ticks.x =  element_line(linewidth = 0.5, color=\"darkgrey\") , \n        axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1)) +\n  labs(title = \"Who Americans spend their time with, by age, Men and Women\", \n        caption = \"Data source: U.S. Bureau of Labor Statistics (2023)\", \n              x = \"Age\", \n       y = \"Hours\") +\n    theme(plot.caption = element_text(hjust = 0)) \n\n\n\n\n\n\n\n\nIt seems that women in their later years spend more time that men alone and less time with a partner, presumably because they are living longer than the men in their lives."
  },
  {
    "objectID": "charts/2025-04-03_circular/index.html",
    "href": "charts/2025-04-03_circular/index.html",
    "title": "day 3 circular",
    "section": "",
    "text": "library(tidyverse)\nlibrary(owidapi)\nlibrary(scales)\nlibrary(ggeasy)\nlibrary(ggannotate)\nlibrary(plotly)\n\ncatalog &lt;- owid_get_catalog()\n\nThis plot illustrates changing representation of women in government leadership. It is great that in 2024 fewer than 2% of governments have no women in leadership, but it is not amazing that fewer than 2% have 50% or more. I am wondering if I can look at this pattern across different areas of the world by making circular graphs in ggplot.\n\n\n\n\nI am mostly interested in the current state of affairs so I read in the data from the owidapi, filter the data to only include 2024 and rename variables to make them more friendly.\n\nshare &lt;- owid_get(\"countries-by-share-of-women-in-parliament\") \n\n\nshare2024 &lt;- share %&gt;% \n  filter(year == 2024) %&gt;%\n  select(-entity_id) %&gt;%\n  rename(number_0pct = num_countries_wom_parl__category_0pct_women, \n         number_0_10pct = num_countries_wom_parl__category_0_10pct_women,\n         number_10_20pct = num_countries_wom_parl__category_10_20pct_women, \n           number_20_30pct = num_countries_wom_parl__category_20_30pct_women, \n           number_30_40pct = num_countries_wom_parl__category_30_40pct_women, \n           number_40_50pct = num_countries_wom_parl__category_40_50pct_women,\n           number_50pluspct = num_countries_wom_parl__category_50pctplus_women) \n\nglimpse(share2024)\n\nRows: 7\nColumns: 9\n$ entity_name      &lt;chr&gt; \"Africa\", \"Asia\", \"Europe\", \"North America\", \"Oceania…\n$ year             &lt;int&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024\n$ number_0pct      &lt;int&gt; 0, 2, 0, 0, 0, 0, 2\n$ number_0_10pct   &lt;int&gt; 4, 7, 0, 0, 4, 0, 15\n$ number_10_20pct  &lt;int&gt; 17, 16, 5, 1, 0, 1, 40\n$ number_20_30pct  &lt;int&gt; 15, 11, 11, 6, 0, 3, 46\n$ number_30_40pct  &lt;int&gt; 10, 5, 15, 3, 1, 5, 39\n$ number_40_50pct  &lt;int&gt; 5, 2, 10, 2, 1, 3, 23\n$ number_50pluspct &lt;int&gt; 1, 0, 0, 2, 0, 0, 3\n\n\n\n\n\nI want to plot data for the World and each region separately so create separate dataframes here using filter(). I also want to make the data long using pivot_longer, mutate new variables that represent the number of countries as percent, improve the labels on the percent categories and make them a factor so that they order correctly in my plot.\n\n# create world dataframe\n\nshare2024_world &lt;- share2024 %&gt;%\n  filter(entity_name == \"World\") %&gt;%\n  pivot_longer(names_to = \"category\", values_to = \"number\", number_0pct:number_50pluspct) %&gt;%\n    mutate(total = sum(number), percent = number/total) %&gt;%\n           mutate(percent_women = case_when(category == \"number_0pct\" ~ \"no women\", \n                           category == \"number_0_10pct\" ~ \"less than 10%\",\n                           category == \"number_10_20pct\" ~ \"10-20%\", \n                           category == \"number_20_30pct\" ~ \"20-30%\", \n                           category == \"number_30_40pct\" ~ \"30-40%\", \n                           category == \"number_40_50pct\" ~ \"40-50%\",\n                           category == \"number_50pluspct\" ~ \"50+%\")) %&gt;%\n    mutate(percent_women = fct_relevel(percent_women, \n                            c(\"no women\" , \"less than 10%\" ,\"10-20%\" ,\n                              \"20-30%\" ,\"30-40%\" , \"40-50%\" ,\n                              \"50+%\"))) \n\n# create regions dataframe\n\nshare2024_regions &lt;- share2024 %&gt;%\n  filter(entity_name != \"World\") %&gt;%\n  pivot_longer(names_to = \"category\", values_to = \"number\", number_0pct:number_50pluspct) %&gt;%\n  group_by(entity_name) %&gt;%\n    mutate(total = sum(number), percent = number/total) %&gt;%\n           mutate(percent_women = case_when(category == \"number_0pct\" ~ \"no women\", \n                           category == \"number_0_10pct\" ~ \"less than 10%\",\n                           category == \"number_10_20pct\" ~ \"10-20%\", \n                           category == \"number_20_30pct\" ~ \"20-30%\", \n                           category == \"number_30_40pct\" ~ \"30-40%\", \n                           category == \"number_40_50pct\" ~ \"40-50%\",\n                           category == \"number_50pluspct\" ~ \"50+%\")) %&gt;%\n    mutate(percent_women = fct_relevel(percent_women, \n                            c(\"no women\" , \"less than 10%\" ,\"10-20%\" ,\n                              \"20-30%\" ,\"30-40%\" , \"40-50%\" ,\n                              \"50+%\"))) \n\n\n\n\n\n\nStarting with world and using inspo from the R Graph gallery here I make an ugly pie chart. There is no pie geom in ggplot, so the workaround is to make a column chart and use coord_polar() to make it circular.\n\nshare2024_world %&gt;%\n  ggplot(aes(x = \"\", y = percent, fill = percent_women)) +\n  geom_col(colour = \"white\") +\n coord_polar(\"y\", start = 0) +\n    theme_void() +\n  easy_add_legend_title(\"Percent seats\") +\n  scale_fill_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#6b3d8d\",  \"#986d39\" )) +\n  labs(title = \"Percent of countries by share of women in parliament in 2024, World\", \n       subtitle = \"Percent of seats in lower or single chamber of the legislature held by women\", \n       caption = \"Data source: V-Dem (2025) via OurWorldInData. \\nNote: Only countries with at least one legislative chamber included.\")\n\n\n\n\n\n\n\n\nThe more interesting question is does this pattern of representation differ across regions?\n\n\n\n\nshare2024_regions %&gt;%\n  ggplot(aes(x = \"\", y = percent, fill = percent_women)) +\n  geom_col(colour = \"white\") +\n coord_polar(\"y\", start = 0) +\n  facet_wrap(~entity_name) +\n    scale_fill_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#6b3d8d\",  \"#986d39\" )) +\n    theme_void() +\n   easy_add_legend_title(\"Percent seats\") +\nlabs(title = \"Percent of countries by share of women in parliament in 2024, Regions\", \n       subtitle = \"Percent of seats in lower or single chamber of the legislature held by women\", \n       caption = \"Data source: V-Dem (2025) via OurWorldInData. \\nNote: Only countries with at least one legislative chamber included.\")\n\n\n\n\n\n\n\n\nThere is a lot that surprises me about this plot. Oceania is not doing well; the majority of countries have less than 10% of government seats held by women. This dataset only includes the number of countries in each region that have women represented in each of the percent categories. This includes 6 Oceanic countries, but it doesn’t include information about which 6 countries are included. I am interested to dig into the country level data here.\nI was also surprised that Asia is the only region that still has 2 countries that have no women in government. Again, I am curious about which 2; Afghanistan maybe? Perhaps there are Middle East countries that do not have women in government."
  },
  {
    "objectID": "charts/2025-04-03_circular/index.html#clean-it-up",
    "href": "charts/2025-04-03_circular/index.html#clean-it-up",
    "title": "day 3 circular",
    "section": "",
    "text": "I want to plot data for the World and each region separately so create separate dataframes here using filter(). I also want to make the data long using pivot_longer, mutate new variables that represent the number of countries as percent, improve the labels on the percent categories and make them a factor so that they order correctly in my plot.\n\n# create world dataframe\n\nshare2024_world &lt;- share2024 %&gt;%\n  filter(entity_name == \"World\") %&gt;%\n  pivot_longer(names_to = \"category\", values_to = \"number\", number_0pct:number_50pluspct) %&gt;%\n    mutate(total = sum(number), percent = number/total) %&gt;%\n           mutate(percent_women = case_when(category == \"number_0pct\" ~ \"no women\", \n                           category == \"number_0_10pct\" ~ \"less than 10%\",\n                           category == \"number_10_20pct\" ~ \"10-20%\", \n                           category == \"number_20_30pct\" ~ \"20-30%\", \n                           category == \"number_30_40pct\" ~ \"30-40%\", \n                           category == \"number_40_50pct\" ~ \"40-50%\",\n                           category == \"number_50pluspct\" ~ \"50+%\")) %&gt;%\n    mutate(percent_women = fct_relevel(percent_women, \n                            c(\"no women\" , \"less than 10%\" ,\"10-20%\" ,\n                              \"20-30%\" ,\"30-40%\" , \"40-50%\" ,\n                              \"50+%\"))) \n\n# create regions dataframe\n\nshare2024_regions &lt;- share2024 %&gt;%\n  filter(entity_name != \"World\") %&gt;%\n  pivot_longer(names_to = \"category\", values_to = \"number\", number_0pct:number_50pluspct) %&gt;%\n  group_by(entity_name) %&gt;%\n    mutate(total = sum(number), percent = number/total) %&gt;%\n           mutate(percent_women = case_when(category == \"number_0pct\" ~ \"no women\", \n                           category == \"number_0_10pct\" ~ \"less than 10%\",\n                           category == \"number_10_20pct\" ~ \"10-20%\", \n                           category == \"number_20_30pct\" ~ \"20-30%\", \n                           category == \"number_30_40pct\" ~ \"30-40%\", \n                           category == \"number_40_50pct\" ~ \"40-50%\",\n                           category == \"number_50pluspct\" ~ \"50+%\")) %&gt;%\n    mutate(percent_women = fct_relevel(percent_women, \n                            c(\"no women\" , \"less than 10%\" ,\"10-20%\" ,\n                              \"20-30%\" ,\"30-40%\" , \"40-50%\" ,\n                              \"50+%\")))"
  },
  {
    "objectID": "charts/2025-04-03_circular/index.html#plot",
    "href": "charts/2025-04-03_circular/index.html#plot",
    "title": "day 3 circular",
    "section": "",
    "text": "Starting with world and using inspo from the R Graph gallery here I make an ugly pie chart. There is no pie geom in ggplot, so the workaround is to make a column chart and use coord_polar() to make it circular.\n\nshare2024_world %&gt;%\n  ggplot(aes(x = \"\", y = percent, fill = percent_women)) +\n  geom_col(colour = \"white\") +\n coord_polar(\"y\", start = 0) +\n    theme_void() +\n  easy_add_legend_title(\"Percent seats\") +\n  scale_fill_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#6b3d8d\",  \"#986d39\" )) +\n  labs(title = \"Percent of countries by share of women in parliament in 2024, World\", \n       subtitle = \"Percent of seats in lower or single chamber of the legislature held by women\", \n       caption = \"Data source: V-Dem (2025) via OurWorldInData. \\nNote: Only countries with at least one legislative chamber included.\")\n\n\n\n\n\n\n\n\nThe more interesting question is does this pattern of representation differ across regions?\n\n\n\n\nshare2024_regions %&gt;%\n  ggplot(aes(x = \"\", y = percent, fill = percent_women)) +\n  geom_col(colour = \"white\") +\n coord_polar(\"y\", start = 0) +\n  facet_wrap(~entity_name) +\n    scale_fill_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#6b3d8d\",  \"#986d39\" )) +\n    theme_void() +\n   easy_add_legend_title(\"Percent seats\") +\nlabs(title = \"Percent of countries by share of women in parliament in 2024, Regions\", \n       subtitle = \"Percent of seats in lower or single chamber of the legislature held by women\", \n       caption = \"Data source: V-Dem (2025) via OurWorldInData. \\nNote: Only countries with at least one legislative chamber included.\")\n\n\n\n\n\n\n\n\nThere is a lot that surprises me about this plot. Oceania is not doing well; the majority of countries have less than 10% of government seats held by women. This dataset only includes the number of countries in each region that have women represented in each of the percent categories. This includes 6 Oceanic countries, but it doesn’t include information about which 6 countries are included. I am interested to dig into the country level data here.\nI was also surprised that Asia is the only region that still has 2 countries that have no women in government. Again, I am curious about which 2; Afghanistan maybe? Perhaps there are Middle East countries that do not have women in government."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome!",
    "section": "",
    "text": "I am a psychologist by training and have been teaching myself (and others) R for a few years now. I am a co-founder of R-Ladies Sydney and developer of #RYouWithMe. This is my place to keep notes about R (and python) things I am learning. This site makes my googling faster! I hope it is useful to you too."
  },
  {
    "objectID": "charts.html",
    "href": "charts.html",
    "title": "30daycharts",
    "section": "",
    "text": "Want to support my chart making? \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 0 challenge\n\n\n\n\n\n\nJen Richmond\n\n\nMar 31, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 1 fractions\n\n\n\n\n\n\nJen Richmond\n\n\nApr 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 2 slope\n\n\n\n\n\n\nJen Richmond\n\n\nApr 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 3 circular\n\n\n\n\n\n\nJen Richmond\n\n\nApr 3, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 4 big small\n\n\n\n\n\n\nJen Richmond\n\n\nApr 4, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 5 ranking\n\n\n\n\n\n\nJen Richmond\n\n\nApr 5, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2022-09-28-git-hints/index.html",
    "href": "posts/2022-09-28-git-hints/index.html",
    "title": "git hints",
    "section": "",
    "text": "I am getting pretty good at avoiding git merge conflicts by always remembering to pull before I push when using github. But the terminal in RStudio has been giving me this hint for a while and I have been ignoring it.\n\nI think this hint is trying to help me but I don’t know what rebase or fast-forward means… to google…\nThis post suggests that I should only use git pull -ff, going as far as setting -ff as a global config setting.\nApparently git pull is actually a two step thing (git fetch + git merge). First, it fetches the content from the remote and then it merges that content into your local. That is USUALLY fine… especially if you are working alone and nothing has changed about your remote repo since the last time you pulled. In this case, your local will be ahead of your remote and git pull will be fine.\nBut if you are using git to collaborate and your team member has pushed some changes to the files you are working on, you can find yourself with a merge conflict.\nThe git pull –ff-only command will fetch and merge content from the remote repo, only if it can be done be done by “fast-fowarding”- that is, without creating new commits. This will only happen if the remote and local haven’t diverged. If they have it will give you a warning.\nMy Twitter friends think that in my use case, when I am mostly working with myself and the remote is unlikely to have diverged from the local, the default option will work fine.\nYay for #rstats twitter!\n\n\nAnyone #rstats know of a helpful rebase vs. fastforward explainer? Which of these options I should choose? My use case is simpler than most. I am not using branches or worried about other people pushing to my repo– just blog/quarto slides to github… thanks #rstats! pic.twitter.com/FAaBLJKAqw\n\n— Jen Richmond @jenrichmondPhD@mastodon.soc (@JenRichmondPhD) October 3, 2022"
  },
  {
    "objectID": "posts/2024-07-04-learning_python/index.html",
    "href": "posts/2024-07-04-learning_python/index.html",
    "title": "learning python",
    "section": "",
    "text": "When you are exploring a far off land and only know a tiny bit of the language they speak there, you always carry a little dictionary with commonly used phrases translated from the language you speak into the other language. It is important to know how to ask someone where the toilets are while you are travelling!\nI have just started learning Python with Posit Academy in the lead up to #positconf2024 and I am trying to approach in the same way I would if I was learning French. A dictionary that helps me link functions I know in R to new functions I am learning in Python could be handy.\nLinking new concepts to old concepts is also a useful learning strategy. Research in Psychology tells us that memory is relational; the brain represents memories as networks of representations. If you can link something that you are trying to learn to something you already know, you are much more likely to remember that new thing into the long term.\n\n\n\n\n\nArt credit: China Blue Art, Memory Network I\n\n\n\n\nOf course, there are probably a million R to Python dictionaries on the internet; why am I creating a new one for me?\nThat’s because we also know that generative learning and retrieval practice are more effective strategies for remembering things into the long term, than are learning strategies that involve passive review of materials that were created by someone else.\nTo create a dictionary of functions as I learn new things in Python, I need to retrieve the equivalent function in R from memory and actively evaluate the similarities and differences between the Python and R versions. That process of retrieving and using the concepts I already know, strengthens both my knowledge of R, and links my new Python understanding to it.\nSo I am starting a googlesheet to keep track of new things I am learning how to do in Python and their R equivalents. Maybe I can read that googlesheet in here using the googlesheets4 package and make it display in a searchable table using gt.\n\ncheat_sheet %&gt;%\n  gt() %&gt;%\n  tab_header(\"My R vs Python cheatsheet\") %&gt;%\n  opt_interactive(use_search = TRUE)\n\n\n\n\nMy R vs Python cheatsheet"
  },
  {
    "objectID": "posts/2022-12-15-colours-that-r-knows/index.html",
    "href": "posts/2022-12-15-colours-that-r-knows/index.html",
    "title": "colours that R knows",
    "section": "",
    "text": "I have been working through the ggplot R Advent calendar by Kiirsti Owen with some lovely RLadies friends and we got up to Day 15 where we started controlling colours in ggplot with scale_fill_manual(). Our immediate question was “how to you know what the names of the colours that R knows are?”\nThis is a “I don’t have to google” post about finding the colours that R knows about.\n\nread the data\n\nlibrary(tidyverse)\n\ntrees &lt;-read_csv(\"https://raw.githubusercontent.com/kiirsti/ggplot_adventcalendaR/main/xmas.trees.csv\")\n\n\n\nmake a plot\n\ntrees %&gt;%\nggplot(aes(x=type, y=height))+\n  geom_boxplot(aes(fill=type), colour=\"black\")+\n  theme_classic()+\n  scale_fill_manual(values=c(\"darkgreen\", \"firebrick2\", \"mediumseagreen\"))\n\n\n\n\n\n\n\n\nYou can have R list the names of all the colours it knows (there are 657 of them) using the colours() function, but that is not so useful if you want to see the difference between aquamarine1 and aquamarine2.\n\n# list the first 20 colours that R knows \n\nhead(colours(), 20)\n\n [1] \"white\"         \"aliceblue\"     \"antiquewhite\"  \"antiquewhite1\"\n [5] \"antiquewhite2\" \"antiquewhite3\" \"antiquewhite4\" \"aquamarine\"   \n [9] \"aquamarine1\"   \"aquamarine2\"   \"aquamarine3\"   \"aquamarine4\"  \n[13] \"azure\"         \"azure1\"        \"azure2\"        \"azure3\"       \n[17] \"azure4\"        \"beige\"         \"bisque\"        \"bisque1\"      \n\n\nWe eventually found a function in the epitools package that will display all the colours and allow you to point a click the ones you want! It doesn’t work so well in an Rmd chunk- you are best to try it in the console.\n\n# install.packages(\"epitools\")\n\nlibrary(epitools)\n\ncolors.plot(locator = TRUE)\n\n\n\n\n\n\n\n\n[1] color.names\n&lt;0 rows&gt; (or 0-length row.names)\n\n\nLoad the epitools package and then use the colors.plot() function in the console, setting locator = TRUE. A matrix will appear in your Plots tab. You can use your mouse to pick the colours you want and then click Finish to have R print the names of those colours to your console. Watch me do it in the screencast below.\n\n\nYou can then use those names to revise your plot colours.\n\ntrees %&gt;%\nggplot(aes(x=type, y=height))+\n  geom_boxplot(aes(fill=type), colour=\"black\")+\n  theme_classic()+\n  scale_fill_manual(values=c(\"seagreen\", \"maroon2\", \"dodgerblue2\"))"
  },
  {
    "objectID": "posts/2021-06-22-pat-for-github/index.html",
    "href": "posts/2021-06-22-pat-for-github/index.html",
    "title": "PAT for GitHub",
    "section": "",
    "text": "I have been avoiding setting up a Personal Access Token to authenticate my github account for a while because it seemed complicated. Never fear Happy Git with R and usethis() to the rescue.\n\ncreate a token\nIn the RStudio console, install the usethis package if you don’t already have it and use it to create a github token.\n\n#install.packages(\"usethis\")\n\nlibrary(usethis)\n\nusethis::create_github_token()\n\nThis will take you to github and make a token for you. Accept the defaults and copy the token.\nGo back to the RStudio console. Install the gitcreds package, if you don’t already have it and then use the gitcreds_set function to tell R you want to set github credentials.\n\n\nstore it in your credentials\n\n# install.packages(\"gitcreds\")\n\nlibrary(gitcreds)\n\ngitcreds_set(url = \"https://github.com\")\n\nThen it will ask you to Enter password or token…paste into your console.\n\n\ncheck that it works\nCheck that it works, using the gitcreds_get() function.\n\ngitcreds_get()"
  },
  {
    "objectID": "posts/2023-04-25-error-bars-on-plots/index.html",
    "href": "posts/2023-04-25-error-bars-on-plots/index.html",
    "title": "error bars on plots",
    "section": "",
    "text": "Repurposing this APA figures post as a IDHTG (I don’t have to google) post.\nAs I write my first paper reporting data analysis coming out of R (woot!!!), here are some notes summarising all the googling I have done this morning about how to produce APA style figures in ggplot.\n\nLoad libraries\nStart by loading tidyverse to get ggplot, here to make finding the data easy, and papaja to get the theme_apa() function.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(here)\n\nhere() starts at /home/runner/work/jenrichmond.github.io/jenrichmond.github.io\n\nlibrary(papaja)\n\nLoading required package: tinylabels\n\n\n\n\nRead in data\n\nplotdata &lt;- read_csv(\"plotdata.csv\")\n\nNew names:\nRows: 8 Columns: 9\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(4): direction, group, detailtype, groupnew dbl (5): ...1, mean, stdev, n,\nstderr\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -&gt; `...1`\n\nhead(plotdata)\n\n# A tibble: 6 × 9\n   ...1 direction group     detailtype  mean stdev     n stderr groupnew       \n  &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          \n1     1 future    control   episodic    9.46  4.04    28  0.764 control group  \n2     2 future    control   semantic    4.57  2.35    28  0.444 control group  \n3     3 future    induction episodic    9.38  3.62    29  0.672 induction group\n4     4 future    induction semantic    4.69  2.85    29  0.530 induction group\n5     5 past      control   episodic   11.2   6.67    28  1.26  control group  \n6     6 past      control   semantic    5.5   5.53    28  1.05  control group  \n\n\n\n\nBasic ggplot (columns)\nPlot separate bars for episodic vs semantic details, by past and future events, separately for kids in the control group vs. induction group. Get pairs of columns using position = “dodge”.\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew)\n\n\n\n\n\n\n\n\n\nAdd error bars\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9))\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\nAPA-ise\nThe theme_apa() from the pajaja package does most of the APAising. Gets rid of the grey and gridlines. But for some reason, now the bars are floating.\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9)) +\n  theme_apa(base_size = 14)\n\n\n\n\n\n\n\n\n\n\nFix x and y axis\nExtend y axis scale and make the bars sit on the x axis\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9)) +\n  theme_apa(base_size = 14) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 15)) # expand 0,0 to make the bars sit down\n\n\n\n\n\n\n\n\n\n\nFix axis labels\nUse the \\n notation to break a label or title across two lines\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9)) +\n  theme_apa(base_size = 14) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 15)) +\n   labs(x=\"Detail type\", y=\"Mean number of details \\n produced\")\n\n\n\n\n\n\n\n\n\n\nMake grey scale\nUse scale_fill_grey(), values 1 = white and 0 = black, specify values in between to get shades of grey\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9)) +\n  theme_apa(base_size = 14) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 15)) +\n   labs(x=\"Detail type\", y=\"Mean number of details \\n produced\") +\n  scale_fill_grey(start = 0.40, end = 0.6) \n\n\n\n\n\n\n\n\n\n\nSave as png to add to your paper\nUse ggsave(“nameoffile.png”) to save the last plot as png.\n\nggsave(\"featured.png\")\n\nSaving 7 x 5 in image"
  },
  {
    "objectID": "posts/2022-06-27-using-lists-in-r/index.html",
    "href": "posts/2022-06-27-using-lists-in-r/index.html",
    "title": "using lists in R",
    "section": "",
    "text": "One of my goals while on long service leave is to learn some new R things that have been on my radar for a while… the first of these is purrr. The purrr package allows you to iterate a function across different elements in a list or dataframe.\nI have started to try and learn purr before (see a list of resources here). I have copied other people’s purrr code a couple of times too…\n\nhow to use map to read in a LOT of .csv files and\nusing pwalk to output plots in different colour schemes\n\n… but when you copy purrr code from someone else and adjust it to suit you own problem… you can’t really say you know how to use purrr.\nThe first thing I think I need to get my head around in order to understand purrr is lists. Dataframes are the bread and butter of the tidyverse and up until now I have avoided them, or tried desperately to use as.dataframe() or unnest() to turn them into a data structure that i understand. Lists allow you to bundle together different kinds of data elements together, so now is the time to get my head around them.\n\nhow to make a list\nThis is a example I copied from a tutorial\nmyfirstlist &lt;-  list(2, \n                     \"hello\", \n                     c(3,5,4), \n                     1:5, \n                     list(FALSE, \n                          c(\"this\", \"is\",\"a\",\"list\"),\n                          c(FALSE,TRUE,TRUE,TRUE,FALSE))) \nThe list() function lets you put elements of all different types (and lengths) into a listy bundle; characters and numbers and logicals. One of the elements in this list of 5 items when others have 3 items or even 1. Another item is ANOTHER list made up of 3 items. Lists within lists— eeeekk. We can use the class() function to check that our list is a list and the str() function to get our head around what we are dealing with.\nclass(myfirstlist)\n## [1] \"list\"\nstr(myfirstlist)\n## List of 5\n##  $ : num 2\n##  $ : chr \"hello\"\n##  $ : num [1:3] 3 5 4\n##  $ : int [1:5] 1 2 3 4 5\n##  $ :List of 3\n##   ..$ : logi FALSE\n##   ..$ : chr [1:4] \"this\" \"is\" \"a\" \"list\"\n##   ..$ : logi [1:5] FALSE TRUE TRUE TRUE FALSE\nThis iconic image (which I think comes from a Jenny Bryan talk) is supposed to help me understand how to access elements of a list.\nLets see if I can unpack it.\n TBC…"
  }
]