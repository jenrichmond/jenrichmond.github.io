[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "blog",
    "section": "",
    "text": "Want to support my blog? \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlearning python\n\n\n\npython\n\n\n\n\n\n\n\nJen Richmond\n\n\nJul 4, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrowwise %&gt;% mean\n\n\n\ndata wrangling\n\n\n\n\n\n\n\nJen Richmond\n\n\nMay 24, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nerror bars on plots\n\n\n\nidhgt\n\n\nggplot\n\n\n\n\n\n\n\nJen Richmond\n\n\nApr 25, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncolours that R knows\n\n\n\nggplot\n\n\n\n\n\n\n\nJen Richmond\n\n\nDec 14, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngit hints\n\n\n\n\n\n\nJen Richmond\n\n\nSep 28, 2022\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-04-25-error-bars-on-plots/index.html",
    "href": "posts/2023-04-25-error-bars-on-plots/index.html",
    "title": "error bars on plots",
    "section": "",
    "text": "Repurposing this APA figures post as a IDHTG (I don’t have to google) post.\nAs I write my first paper reporting data analysis coming out of R (woot!!!), here are some notes summarising all the googling I have done this morning about how to produce APA style figures in ggplot.\n\nLoad libraries\nStart by loading tidyverse to get ggplot, here to make finding the data easy, and papaja to get the theme_apa() function.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(here)\n\nhere() starts at /home/runner/work/jenrichmond.github.io/jenrichmond.github.io\n\nlibrary(papaja)\n\nLoading required package: tinylabels\n\n\n\n\nRead in data\n\nplotdata &lt;- read_csv(\"plotdata.csv\")\n\nNew names:\nRows: 8 Columns: 9\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(4): direction, group, detailtype, groupnew dbl (5): ...1, mean, stdev, n,\nstderr\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -&gt; `...1`\n\nhead(plotdata)\n\n# A tibble: 6 × 9\n   ...1 direction group     detailtype  mean stdev     n stderr groupnew       \n  &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;          \n1     1 future    control   episodic    9.46  4.04    28  0.764 control group  \n2     2 future    control   semantic    4.57  2.35    28  0.444 control group  \n3     3 future    induction episodic    9.38  3.62    29  0.672 induction group\n4     4 future    induction semantic    4.69  2.85    29  0.530 induction group\n5     5 past      control   episodic   11.2   6.67    28  1.26  control group  \n6     6 past      control   semantic    5.5   5.53    28  1.05  control group  \n\n\n\n\nBasic ggplot (columns)\nPlot separate bars for episodic vs semantic details, by past and future events, separately for kids in the control group vs. induction group. Get pairs of columns using position = “dodge”.\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew)\n\n\n\n\n\n\n\n\n\nAdd error bars\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9))\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\nAPA-ise\nThe theme_apa() from the pajaja package does most of the APAising. Gets rid of the grey and gridlines. But for some reason, now the bars are floating.\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9)) +\n  theme_apa(base_size = 14)\n\n\n\n\n\n\n\n\n\n\nFix x and y axis\nExtend y axis scale and make the bars sit on the x axis\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9)) +\n  theme_apa(base_size = 14) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 15)) # expand 0,0 to make the bars sit down\n\n\n\n\n\n\n\n\n\n\nFix axis labels\nUse the \\n notation to break a label or title across two lines\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9)) +\n  theme_apa(base_size = 14) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 15)) +\n   labs(x=\"Detail type\", y=\"Mean number of details \\n produced\")\n\n\n\n\n\n\n\n\n\n\nMake grey scale\nUse scale_fill_grey(), values 1 = white and 0 = black, specify values in between to get shades of grey\n\nplotdata %&gt;%\n  ggplot(aes(x= detailtype, y = mean, fill = direction)) +\n    geom_col(position = \"dodge\") +\n  facet_wrap(~ groupnew) + geom_errorbar(aes(ymin=mean-stderr, ymax=mean+stderr),\n                  size=.3,    # Thinner lines\n                    width=.2,\n                      position=position_dodge(.9)) +\n  theme_apa(base_size = 14) +\n  scale_y_continuous(expand = c(0, 0), limits = c(0, 15)) +\n   labs(x=\"Detail type\", y=\"Mean number of details \\n produced\") +\n  scale_fill_grey(start = 0.40, end = 0.6) \n\n\n\n\n\n\n\n\n\n\nSave as png to add to your paper\nUse ggsave(“nameoffile.png”) to save the last plot as png.\n\nggsave(\"featured.png\")\n\nSaving 7 x 5 in image"
  },
  {
    "objectID": "posts/2022-12-15-colours-that-r-knows/index.html",
    "href": "posts/2022-12-15-colours-that-r-knows/index.html",
    "title": "colours that R knows",
    "section": "",
    "text": "I have been working through the ggplot R Advent calendar by Kiirsti Owen with some lovely RLadies friends and we got up to Day 15 where we started controlling colours in ggplot with scale_fill_manual(). Our immediate question was “how to you know what the names of the colours that R knows are?”\nThis is a “I don’t have to google” post about finding the colours that R knows about.\n\nread the data\n\nlibrary(tidyverse)\n\ntrees &lt;-read_csv(\"https://raw.githubusercontent.com/kiirsti/ggplot_adventcalendaR/main/xmas.trees.csv\")\n\n\n\nmake a plot\n\ntrees %&gt;%\nggplot(aes(x=type, y=height))+\n  geom_boxplot(aes(fill=type), colour=\"black\")+\n  theme_classic()+\n  scale_fill_manual(values=c(\"darkgreen\", \"firebrick2\", \"mediumseagreen\"))\n\n\n\n\n\n\n\n\nYou can have R list the names of all the colours it knows (there are 657 of them) using the colours() function, but that is not so useful if you want to see the difference between aquamarine1 and aquamarine2.\n\n# list the first 20 colours that R knows \n\nhead(colours(), 20)\n\n [1] \"white\"         \"aliceblue\"     \"antiquewhite\"  \"antiquewhite1\"\n [5] \"antiquewhite2\" \"antiquewhite3\" \"antiquewhite4\" \"aquamarine\"   \n [9] \"aquamarine1\"   \"aquamarine2\"   \"aquamarine3\"   \"aquamarine4\"  \n[13] \"azure\"         \"azure1\"        \"azure2\"        \"azure3\"       \n[17] \"azure4\"        \"beige\"         \"bisque\"        \"bisque1\"      \n\n\nWe eventually found a function in the epitools package that will display all the colours and allow you to point a click the ones you want! It doesn’t work so well in an Rmd chunk- you are best to try it in the console.\n\n# install.packages(\"epitools\")\n\nlibrary(epitools)\n\ncolors.plot(locator = TRUE)\n\n\n\n\n\n\n\n\n[1] color.names\n&lt;0 rows&gt; (or 0-length row.names)\n\n\nLoad the epitools package and then use the colors.plot() function in the console, setting locator = TRUE. A matrix will appear in your Plots tab. You can use your mouse to pick the colours you want and then click Finish to have R print the names of those colours to your console. Watch me do it in the screencast below.\n\n\nYou can then use those names to revise your plot colours.\n\ntrees %&gt;%\nggplot(aes(x=type, y=height))+\n  geom_boxplot(aes(fill=type), colour=\"black\")+\n  theme_classic()+\n  scale_fill_manual(values=c(\"seagreen\", \"maroon2\", \"dodgerblue2\"))"
  },
  {
    "objectID": "posts/2022-09-28-git-hints/index.html",
    "href": "posts/2022-09-28-git-hints/index.html",
    "title": "git hints",
    "section": "",
    "text": "I am getting pretty good at avoiding git merge conflicts by always remembering to pull before I push when using github. But the terminal in RStudio has been giving me this hint for a while and I have been ignoring it.\n\nI think this hint is trying to help me but I don’t know what rebase or fast-forward means… to google…\nThis post suggests that I should only use git pull -ff, going as far as setting -ff as a global config setting.\nApparently git pull is actually a two step thing (git fetch + git merge). First, it fetches the content from the remote and then it merges that content into your local. That is USUALLY fine… especially if you are working alone and nothing has changed about your remote repo since the last time you pulled. In this case, your local will be ahead of your remote and git pull will be fine.\nBut if you are using git to collaborate and your team member has pushed some changes to the files you are working on, you can find yourself with a merge conflict.\nThe git pull –ff-only command will fetch and merge content from the remote repo, only if it can be done be done by “fast-fowarding”- that is, without creating new commits. This will only happen if the remote and local haven’t diverged. If they have it will give you a warning.\nMy Twitter friends think that in my use case, when I am mostly working with myself and the remote is unlikely to have diverged from the local, the default option will work fine.\nYay for #rstats twitter!\n\n\nAnyone #rstats know of a helpful rebase vs. fastforward explainer? Which of these options I should choose? My use case is simpler than most. I am not using branches or worried about other people pushing to my repo– just blog/quarto slides to github… thanks #rstats! pic.twitter.com/FAaBLJKAqw\n\n— Jen Richmond @jenrichmondPhD@mastodon.soc (@JenRichmondPhD) October 3, 2022"
  },
  {
    "objectID": "charts.html",
    "href": "charts.html",
    "title": "30daycharts",
    "section": "",
    "text": "Want to support my chart making? \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 0 challenge\n\n\n\n\n\n\nJen Richmond\n\n\nMar 31, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 1 fractions\n\n\n\n\n\n\nJen Richmond\n\n\nApr 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nday 2 slope\n\n\n\n\n\n\nJen Richmond\n\n\nApr 2, 2025\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome!",
    "section": "",
    "text": "I am a psychologist by training and have been teaching myself (and others) R for a few years now. I am a co-founder of R-Ladies Sydney and developer of #RYouWithMe. This is my place to keep notes about R (and python) things I am learning. This site makes my googling faster! I hope it is useful to you too."
  },
  {
    "objectID": "charts/2025-04-01_fractions/index.html",
    "href": "charts/2025-04-01_fractions/index.html",
    "title": "day 1 fractions",
    "section": "",
    "text": "This plot from Our World in Data illustrates the proportion of people who are willing to donate 1% of their income to climate change efforts as a function of people’s estimate of how many people in their country would be willing to donate.\nAs it turns out, people have a rather dim view of the likelihood that others would commit to supporting climate action. Lets see if we can reproduce the chart using ggplot.\n\n\n\nload packages\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(owidapi)\nlibrary(scales)\nlibrary(ggeasy)\nlibrary(ggrepel)\nlibrary(plotly)\n\ncatalog &lt;- owid_get_catalog()\n\n\n\nread in the data\nHere I am using the owidapi package to read in the data and reordering/renaming some variables before sorting the data by country and year.\n\nwillingness &lt;- owid_get(\"willingness-climate-action\") %&gt;%\n  select(entity_name, entity_id, owid_region, year, \n         prediction_others_willingness = willingness_contribute_1pct_climate_others, \n         self_willingness = willingness_contribute_pct_climate) %&gt;%\n   arrange(entity_id, year)\n\n\nglimpse(willingness)\n\nRows: 397\nColumns: 6\n$ entity_name                   &lt;chr&gt; \"Democratic Republic of Vietnam\", \"Duchy…\n$ entity_id                     &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", …\n$ owid_region                   &lt;chr&gt; \"Asia\", \"Europe\", \"Europe\", \"North Ameri…\n$ year                          &lt;int&gt; 2023, 2023, 2023, 2023, 2023, 2023, 2023…\n$ prediction_others_willingness &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ self_willingness              &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n\n\n\n\nclean up the data\nLooks like the plot only includes 2024 data, so lets filter first.\n\nwillingness2024 &lt;- willingness %&gt;%\n  filter(year == 2024) \n \n\nglimpse(willingness2024)\n\nRows: 126\nColumns: 6\n$ entity_name                   &lt;chr&gt; \"Afghanistan\", \"Albania\", \"United Arab E…\n$ entity_id                     &lt;chr&gt; \"AFG\", \"ALB\", \"ARE\", \"ARG\", \"ARM\", \"AUS\"…\n$ owid_region                   &lt;chr&gt; \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", …\n$ year                          &lt;int&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024…\n$ prediction_others_willingness &lt;dbl&gt; 40.5, 43.8, 53.9, 38.1, 40.7, 38.6, 37.9…\n$ self_willingness              &lt;dbl&gt; 82.0, 71.3, 81.7, 62.2, 75.4, 56.1, 72.7…\n\n\nUnfortunately in filtering out the 2023 data, I have also lost information about the owid region, which is used in colouring the dots in the plot. I need to go back to the dataset that has regions for 2023 and have them propogate into the 2024 rows as well.\nThis chunk groups the data by country and then mutates a new column to contain new region values. It looks just at 2023 rows and pulls the first value of region from those. Then we can filter for just 2024 values.\n\nwillingness2024 &lt;- willingness %&gt;%\n  group_by(entity_name) %&gt;%\n  mutate(region = first(owid_region[year == 2023])) %&gt;%\n  select(starts_with(\"entity\"), region, year, ends_with(\"willingness\")) %&gt;%\n  filter(year == 2024) \n \nglimpse(willingness2024)\n\nRows: 126\nColumns: 6\nGroups: entity_name [126]\n$ entity_name                   &lt;chr&gt; \"Afghanistan\", \"Albania\", \"United Arab E…\n$ entity_id                     &lt;chr&gt; \"AFG\", \"ALB\", \"ARE\", \"ARG\", \"ARM\", \"AUS\"…\n$ region                        &lt;chr&gt; \"Asia\", \"Europe\", \"Asia\", \"South America…\n$ year                          &lt;int&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024…\n$ prediction_others_willingness &lt;dbl&gt; 40.5, 43.8, 53.9, 38.1, 40.7, 38.6, 37.9…\n$ self_willingness              &lt;dbl&gt; 82.0, 71.3, 81.7, 62.2, 75.4, 56.1, 72.7…\n\n\n\n\nmake a basic plot\n\nwillingness2024 %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness)) +\n  geom_point() +\n  scale_y_continuous(limits = c(0,100)) +\n    scale_x_continuous(limits = c(0,100)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\") \n\n\n\n\n\n\n\n\nOK, basic plot success… things that I need to change\n\naxis values in 20% increments with %\ntheme needs to be white background with dotted gridlines on 20% values\ndiagonal dotted line\ncolour points by region\ninclude text of selection of countries\ncaption re data source\ntitle and subtitle\nplotly interactivity\n\n\n\ngridlines and axes\nHere I am using the expand and breaks arguments within scale_y_continuous and scale_x_continuous to make the axis start at 0,0 and have 20% increments. I get % labels on each access using the percent_format() function from the scales package (accuracy = 1 tells R I want it to display whole numbers and scale = 1 tells R my numbers are already percentages and don’t need to be multiplied by 100).\nI removed the minor gridlines using easy_remove_gridlines() from the ggeasy package. I also added a diagonal line usinggeom_abline().\n\nwillingness2024 %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness)) +\n  geom_point() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n    scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                       limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\") +\n  theme_bw()  +\n  easy_remove_gridlines(axis = \"both\", minor = TRUE, major = FALSE) +\n  geom_abline(\n    slope = 1, \n    intercept = 0, \n    color = \"grey\", \n    linetype = \"dotted\")\n\n\n\n\n\n\n\n\n\n\ncolours and text\nAdding colour by region makes me realise that there is a row that entity_name == World, which doesn’t have a region. I need to filtered the World out to avoid an NA category.\nI want to use the same colours as the OWID plot. The ColorZilla web extension allows you to use a dropper to get the specific # codes for each colour on any plot on the internet- handy!\nI have used scale_colour_manual() to set the colours and added a title and subtitle using labs and removed the legend title using a function from the ggeasy package. I have added some country labels, while trying to avoid overlapping the point using the geom_text_repel() function from the ggrepel package. It does give me a warning that there are too many overlapping points though.\n\nwillingness2024 %&gt;%\n  filter(entity_name != \"World\") %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness, colour = region)) +\n  geom_point() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n    scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                       limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\", \n       title = \"People underestimate others' willingness to take climate action\", \n       subtitle = \"Participants were asked if they would contribute 1% of their income to tackle \\nclimate change. \\nThe share that answered 'yes' is shown on the horizontal axis. \\nThe share of the population in their country that people think would be willing \\nis shown on the vertical axis.\") +\n  theme_bw()  +\n  easy_remove_gridlines(axis = \"both\", minor = TRUE, major = FALSE) +\n  geom_abline(\n    slope = 1, \n    intercept = 0, \n    color = \"grey\", \n    linetype = \"dotted\") +\n  scale_colour_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#883039\")) +\n  easy_remove_legend_title() +\n  geom_text_repel(aes(label = entity_name), size = 3, max.overlaps = 20)\n\n\n\n\n\n\n\n\n\n\ninteractivity\nThe plotly packages allows for much of the same kind of interactivity that the grapher tool allows on Our World in Data. Here I have added an extra text argument to the ggplot aes to make the hover option display the country associated with each point, as well as the variables that were mapped. By assigning the ggplot to an object and then using the ggplotly() function, we can produce an interactive plot.\n\nplot &lt;- willingness2024 %&gt;%\n  filter(entity_name != \"World\") %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness, \n             colour = region, text = paste(\"country:\", entity_name))) +\n  geom_point() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n    scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                       limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\", \n       title = \"People underestimate others' willingness to take climate action\", \n       subtitle = \"Participants were asked if they would contribute 1% of their income to tackle climate change. \\nThe share that answered 'yes' is shown on the horizontal axis. The share of the population \\nin their country that people think would be willing is shown on the vertical axis.\") +\n  theme_bw()  +\n  theme(panel.grid.minor = element_blank()) +\n  geom_abline(\n    slope = 1, \n    intercept = 0, \n    color = \"grey\", \n    linetype = \"dotted\") +\n  scale_colour_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#883039\")) +\n  easy_remove_legend_title() \n\ninteractive_plot &lt;- ggplotly(plot)\n\ninteractive_plot"
  },
  {
    "objectID": "charts/2025-04-02_slope/index.html",
    "href": "charts/2025-04-02_slope/index.html",
    "title": "day 2 slope",
    "section": "",
    "text": "This plot from Our World in Data illustrates the amount of time that we spend with others and how that changes with age. The slope of line plotting the amount of time that people spend alone is pretty terrifying. Lets see if we can reproduce that plot using ggplot.\n\n\n\nload packages\n\nlibrary(tidyverse)\nlibrary(owidapi)\nlibrary(scales)\nlibrary(ggeasy)\nlibrary(ggannotate)\n\n# remotes::install_github(\"mattcowgill/ggannotate\")\n\ncatalog &lt;- owid_get_catalog()\n\n\n\nread in the data\nHere I am reading the data using the owidapi package and selecting and renaming columns within the same line of code. I also want to make the data long so that the category information appears in a single column and the hours values in another.\nI know that colours are often easier to deal with if we turn character variables into factors so that we can set the order. Here I use fct_relevel() to order the categories so that I can easily line up which colour is associated with each.\n\ntime &lt;- owid_get(\"time-spent-with-relationships-by-age-us\") %&gt;%\n  select(group = entity_name, age = year, \n         alone = t__who_category_alone, friend = t__who_category_friend, \n         children = t__who_category_children, family = t__who_category_family, \n         partner = t__who_category_partner, coworker = t__who_category_co_worker) %&gt;%\n  pivot_longer(names_to = \"category\", values_to = \"hours\", alone:coworker)\n\n\ntime$category &lt;- fct_relevel(time$category, c(\"alone\", \"partner\", \"family\", \"children\", \"friend\", \"coworker\"))\n\nlevels(time$category) #check levels\n\n[1] \"alone\"    \"partner\"  \"family\"   \"children\" \"friend\"   \"coworker\"\n\nglimpse(time)\n\nRows: 1,206\nColumns: 4\n$ group    &lt;chr&gt; \"All people\", \"All people\", \"All people\", \"All people\", \"All …\n$ age      &lt;int&gt; 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 1…\n$ category &lt;fct&gt; alone, friend, children, family, partner, coworker, alone, fr…\n$ hours    &lt;dbl&gt; 3.629829200, 1.584973700, 0.363883400, 4.324233500, 0.0000000…\n\n\n\n\nmake basic plot\nThe dataset contains time use data for Male and Female separate, but lets start with a plot of All people.\n\ntime %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point() + \n  geom_line() \n\n\n\n\n\n\n\n\nBasic plot… check! Here is a list of things I would like to change…\n\ntheme and colours\nadd horizontal gridlines\nfilter out data point more than 80\nstart x axis at 15, 30 then in increments of 10\ny axis add h to numbers\nadd group annotations rather than legend\n\n\n\ntheme and colours\nI started by filtering out data with age values greater than 80. I used the ColorZilla web extension to get the # codes for the colours in the Our World in Data plot and scale_colour_manual() to set the colours.\nI fixed the y axis using scale_y_continuous() breaks and got most of the way there with theme_minimal(). The easy_remove_gridlines() function from ggeasy makes it easy to control which gridlines you want to display. Here I want to remove both major and minor verticial lines but keep the major horizontal lines. I want the gridlines to be dotted and use the theme(panel.grid = element_line() to achieve that.\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  scale_y_continuous(expand = c(0,0), breaks = seq(0,8,1)) +\n  theme_minimal() +\n  easy_remove_gridlines(axis = \"x\", major = TRUE, minor = TRUE) +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth = 0.4, linetype = 2))\n\n\n\n\n\n\n\n\n\n\naxes\nNow theme_minimal() removes the x and y axis lines and ticks. I want to add the line/ticks back in on just the x axis so use theme(axis.line.x = element_line()and theme(axis.ticks.x = element_line().\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,8.1), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth = 0.4, linetype = 2)) +\n  theme(axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1), \n        axis.ticks.x = element_line(linewidth = 0.5, color=\"darkgrey\")\n        )\n\n\n\n\n\n\n\n\n\n\nannotations\nThe easy_remove_legend() function from the ggeasy package makes it easy to get rid of a legend; getting annotations on the end of the each line is a bit tricker. I’m sure there is a simpler way, but the ggannotate package by Matt Cowgill pulls up a shiny panel that allows you to place annotations where you want them and then copy the geom_text() code into your chunk.\n\n  time %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,8.1), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth = 0.4, linetype = 2)) +\n  theme(axis.ticks.x =   element_line(linewidth = 0.5, color=\"darkgrey\") , \n        axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1)) +\n  easy_remove_legend() +\n  geom_text(data = data.frame(x = 82, y = 8, \n    label = \"Alone\"), aes(x = x, y = y, label = label), size = 3, colour = \"#496899\") +\n  geom_text(data = data.frame(x = 82, y = 4.4, \n    label = \"With \\npartner\"), aes(x = x, y = y, label = label), size = 3,colour = \"#6b3d8d\") +\n  geom_text(data = data.frame(x = 80, y = 1.3, \n    label = \"With family\"),aes(x = x, y = y, label = label), size = 3, colour = \"#2b8465\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.7, \n    label = \"With children\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#986d39\") +\n geom_text(data = data.frame(x = 83.5, y = 0.5, \n    label = \"With friends\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#b03508\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.1, \n    label = \"With coworkers\"), aes(x = x, y = y, label = label), size = 2.5, colour = \"#883039\")\n\n\n\n\n\n\n\n\n\n\ntitles and captions\nFinishing touches… title, subtitle and caption. The theme(plot.caption = element_text(hjust = 0)) makes the caption appear on the left side of the plot.\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,8.1), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth =  0.4, linetype = 2)) +\n  theme(axis.ticks.x =  element_line(linewidth = 0.5, color=\"darkgrey\") , \n        axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1)) +\n  easy_remove_legend() +\n  ### the geom_text code below are created using the ggannotate package\n  geom_text(data = data.frame(x = 82, y = 7.8, \n    label = \"Alone\"), aes(x = x, y = y, label = label), size = 3, colour = \"#496899\") +\n  geom_text(data = data.frame(x = 82, y = 4.4, \n    label = \"With \\npartner\"), aes(x = x, y = y, label = label), size = 3,colour = \"#6b3d8d\") +\n  geom_text(data = data.frame(x = 80, y = 1.3, \n    label = \"With family\"),aes(x = x, y = y, label = label), size = 3, colour = \"#2b8465\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.7, \n    label = \"With children\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#986d39\") +\n geom_text(data = data.frame(x = 83.5, y = 0.5, \n    label = \"With friends\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#b03508\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.1, \n    label = \"With coworkers\"), aes(x = x, y = y, label = label), size = 2.5, colour = \"#883039\") +\n  labs(title = \"Who Americans spend their time with, by age, All people\", \n       subtitle = \"Measured in hours per day, based on averages from surveys in the United States \\nbetween 2010 and 2023\", \n       x = \"Age\", \n       y = \"Hours\",\n       caption = \"Data source: U.S. Bureau of Labor Statistics (2023). \\nNote: Activities such as sleeping, grooming, and personal care are not included in the data. \\nRelationships used to categorize people are not exhaustive and time spent with multiple people counts toward all \\n(e.g., attending a party with friends and partner counts toward both friends and partner)\") +\n  theme(plot.caption = element_text(hjust = 0)) # make the caption appear on the left\n\n\n\n\n\n\n\n\n\n\nbonus\nAt this point I am wondering whether who people spend their time with differs for men and women. Here I have changed the filter to include both Men and Women and added a facet_wrap(~group) to plot the gender data separately.\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group %in% c(\"Men\", \"Women\")) %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  facet_wrap(~ group) +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,10), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth =  0.4, linetype = 2)) +\n  theme(axis.ticks.x =  element_line(linewidth = 0.5, color=\"darkgrey\") , \n        axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1)) +\n  labs(title = \"Who Americans spend their time with, by age, Men and Women\", \n        caption = \"Data source: U.S. Bureau of Labor Statistics (2023)\", \n              x = \"Age\", \n       y = \"Hours\") +\n    theme(plot.caption = element_text(hjust = 0)) \n\n\n\n\n\n\n\n\nIt seems that women in their later years spend more time that men alone and less time with a partner, presumably because they are living longer than the men in their lives."
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html",
    "href": "charts/2025-03-31_challenge/index.html",
    "title": "day 0 challenge",
    "section": "",
    "text": "I have some time on my hands at the moment and thought the #30DayChartChallenge might be a good way to refresh my ggplot skills.\nThe Our World in Data is a fun place to explore data visualisations. They always make really interesting plots out of all kinds of different data, but they use an in-house data viz platform called “Grapher” so it isn’t easy to find code that can be used to reproduce the charts.\nMy goal in April is use the 30 day chart challenge prompt to find a Our World in Data plot that looks interesting, and then to try to reproduce the plot using ggplot code.\nI will post the final code for each plot in a tabset below, but if you want to see how each chart came about (i.e. my troubleshooting process), there will be a blog post associated with each one.\nThe owidapi package is an easy way to get access to the data sources that the Our World in Data site uses.\nlibrary(owidapi)\n\ncatalog &lt;- owid_get_catalog()\n\nwillingness &lt;- owid_get(\"willingness-climate-action\")"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-1-fractions",
    "href": "charts/2025-03-31_challenge/index.html#day-1-fractions",
    "title": "day 0 challenge",
    "section": "Day 1 fractions",
    "text": "Day 1 fractions\nWillingness climate action\n\nmy plotr code\n\n\n\n\n\n\nwillingness2024 %&gt;%\n  filter(entity_name != \"World\") %&gt;%\n  ggplot(aes(y =  prediction_others_willingness, x = self_willingness, colour = region)) +\n  geom_point() +\n  scale_y_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                      limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n    scale_x_continuous(labels = percent_format(accuracy = 1, scale = 1), \n                       limits = c(0,100), expand = c(0,0), breaks = seq(0,100,20)) +\n  labs(y = \"Predicted share willing to give\", \n       x = \"Actual share who said they were willing to give 1% of their income\", \n       title = \"People underestimate others' willingness to take climate action\", \n       subtitle = \"Participants were asked if they would contribute 1% of their income to tackle \\nclimate change. \\nThe share that answered 'yes' is shown on the horizontal axis. \\nThe share of the population in their country that people think would be willing \\nis shown on the vertical axis.\") +\n  theme_bw()  +\n  easy_remove_gridlines(axis = \"both\", minor = TRUE, major = FALSE) +\n  geom_abline(\n    slope = 1, \n    intercept = 0, \n    color = \"grey\", \n    linetype = \"dotted\") +\n  scale_colour_manual(values = c(\"#a2559b\", \"#00847d\", \"#4b6a9c\", \"#e56e59\", \"#38aaba\", \"#883039\")) +\n  easy_remove_legend_title() +\n  geom_text_repel(aes(label = entity_name), size = 3, max.overlaps = 20)"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-2-slope",
    "href": "charts/2025-03-31_challenge/index.html#day-2-slope",
    "title": "day 0 challenge",
    "section": "Day 2 slope",
    "text": "Day 2 slope\nTime spent alone\n\nmy plotr code\n\n\n\n\n\n\ntime %&gt;%\n  filter(age &lt; 80) %&gt;%\n  filter(group == \"All people\") %&gt;%\n  ggplot(aes(x = age, y = hours, colour = category)) +\n  geom_point(size = 1) + \n  geom_line() +\n  scale_colour_manual(values = c(\"#496899\", \"#6b3d8d\", \"#2b8465\", \"#986d39\", \"#b03508\", \"#883039\")) +\n  theme_minimal() +\n  scale_y_continuous(expand = c(0,0), limits = c(-0.05,8.1), breaks = seq(0,9,1)) +\n  scale_x_continuous(breaks=c(15,30,40,50,60,70,80)) +\n  easy_remove_gridlines(axis = \"x\") +\n  easy_remove_gridlines(axis = \"y\", major = FALSE, minor = TRUE) +\n  theme(panel.grid = element_line(linewidth =  0.4, linetype = 2)) +\n  theme(axis.ticks.x =  element_line(linewidth = 0.5, color=\"darkgrey\") , \n        axis.line.x = element_line(linewidth = 0.2, colour = \"darkgrey\", linetype=1)) +\n  easy_remove_legend() +\n  ### the geom_text code below are created using the ggannotate package\n  geom_text(data = data.frame(x = 82, y = 7.8, \n    label = \"Alone\"), aes(x = x, y = y, label = label), size = 3, colour = \"#496899\") +\n  geom_text(data = data.frame(x = 82, y = 4.4, \n    label = \"With \\npartner\"), aes(x = x, y = y, label = label), size = 3,colour = \"#6b3d8d\") +\n  geom_text(data = data.frame(x = 80, y = 1.3, \n    label = \"With family\"),aes(x = x, y = y, label = label), size = 3, colour = \"#2b8465\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.7, \n    label = \"With children\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#986d39\") +\n geom_text(data = data.frame(x = 83.5, y = 0.5, \n    label = \"With friends\"), aes(x = x, y = y, label = label), size = 2.5,colour = \"#b03508\") +\n  geom_text(data = data.frame(x = 83.5, y = 0.1, \n    label = \"With coworkers\"), aes(x = x, y = y, label = label), size = 2.5, colour = \"#883039\") +\n  labs(title = \"Who Americans spend their time with, by age, All people\", \n       subtitle = \"Measured in hours per day, based on averages from surveys in the United States \\nbetween 2010 and 2023\", \n       x = \"Age\", \n       y = \"Hours\",\n       caption = \"Data source: U.S. Bureau of Labor Statistics (2023). \\nNote: Activities such as sleeping, grooming, and personal care are not included in the data. \\nRelationships used to categorize people are not exhaustive and time spent with multiple people counts toward all \\n(e.g., attending a party with friends and partner counts toward both friends and partner)\") +\n  theme(plot.caption = element_text(hjust = 0)) # make the caption appear on the left"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-3-circular",
    "href": "charts/2025-03-31_challenge/index.html#day-3-circular",
    "title": "day 0 challenge",
    "section": "Day 3 circular",
    "text": "Day 3 circular\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-4-big-small",
    "href": "charts/2025-03-31_challenge/index.html#day-4-big-small",
    "title": "day 0 challenge",
    "section": "Day 4 big small",
    "text": "Day 4 big small\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-5-ranking",
    "href": "charts/2025-03-31_challenge/index.html#day-5-ranking",
    "title": "day 0 challenge",
    "section": "Day 5 ranking",
    "text": "Day 5 ranking\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-6-florence",
    "href": "charts/2025-03-31_challenge/index.html#day-6-florence",
    "title": "day 0 challenge",
    "section": "Day 6 florence",
    "text": "Day 6 florence\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-7-outliers",
    "href": "charts/2025-03-31_challenge/index.html#day-7-outliers",
    "title": "day 0 challenge",
    "section": "Day 7 outliers",
    "text": "Day 7 outliers\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code"
  },
  {
    "objectID": "charts/2025-03-31_challenge/index.html#day-8-histogram",
    "href": "charts/2025-03-31_challenge/index.html#day-8-histogram",
    "title": "day 0 challenge",
    "section": "Day 8 histogram",
    "text": "Day 8 histogram\n\nmy plotr code\n\n\n\n\n\n\n# insert ggplot code\n\n\n\n\n:::"
  },
  {
    "objectID": "posts/2024-07-04-learning_python/index.html",
    "href": "posts/2024-07-04-learning_python/index.html",
    "title": "learning python",
    "section": "",
    "text": "When you are exploring a far off land and only know a tiny bit of the language they speak there, you always carry a little dictionary with commonly used phrases translated from the language you speak into the other language. It is important to know how to ask someone where the toilets are while you are travelling!\nI have just started learning Python with Posit Academy in the lead up to #positconf2024 and I am trying to approach in the same way I would if I was learning French. A dictionary that helps me link functions I know in R to new functions I am learning in Python could be handy.\nLinking new concepts to old concepts is also a useful learning strategy. Research in Psychology tells us that memory is relational; the brain represents memories as networks of representations. If you can link something that you are trying to learn to something you already know, you are much more likely to remember that new thing into the long term.\n\n\n\n\n\nArt credit: China Blue Art, Memory Network I\n\n\n\n\nOf course, there are probably a million R to Python dictionaries on the internet; why am I creating a new one for me?\nThat’s because we also know that generative learning and retrieval practice are more effective strategies for remembering things into the long term, than are learning strategies that involve passive review of materials that were created by someone else.\nTo create a dictionary of functions as I learn new things in Python, I need to retrieve the equivalent function in R from memory and actively evaluate the similarities and differences between the Python and R versions. That process of retrieving and using the concepts I already know, strengthens both my knowledge of R, and links my new Python understanding to it.\nSo I am starting a googlesheet to keep track of new things I am learning how to do in Python and their R equivalents. Maybe I can read that googlesheet in here using the googlesheets4 package and make it display in a searchable table using gt.\n\ncheat_sheet %&gt;%\n  gt() %&gt;%\n  tab_header(\"My R vs Python cheatsheet\") %&gt;%\n  opt_interactive(use_search = TRUE)\n\n\n\n\nMy R vs Python cheatsheet"
  },
  {
    "objectID": "posts/2023-05-24-rowwise-mean/index.html",
    "href": "posts/2023-05-24-rowwise-mean/index.html",
    "title": "rowwise %>% mean",
    "section": "",
    "text": "When you have data from a survey, the responses for each item are most often listed in different variables. Generally you have to average across the items to get a mean value for that scale for each participant. But dealing with calculations across rows is sometimes difficult in R.\n\nPhoto by Travis Essinger on Unsplash\n\nload packages + make some data\n\nlibrary(tidyverse)\n\n\npID &lt;- c(\"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\")\nitem1 = sample(1:7, 6, replace=T)\nitem2 = sample(1:7, 6, replace=T)\nitem3 = sample(1:7, 6, replace=T)\nitem4 = sample(1:7, 6, replace=T)\nitem5 = sample(1:7, 6, replace=T)\n\nsurvey &lt;- data.frame(pID, item1, item2, item3, item4, item5)\n\nglimpse(survey)\n\nRows: 6\nColumns: 6\n$ pID   &lt;chr&gt; \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"\n$ item1 &lt;int&gt; 5, 7, 5, 4, 6, 4\n$ item2 &lt;int&gt; 2, 3, 1, 2, 6, 1\n$ item3 &lt;int&gt; 5, 3, 1, 4, 3, 6\n$ item4 &lt;int&gt; 4, 4, 1, 1, 7, 7\n$ item5 &lt;int&gt; 6, 6, 5, 4, 6, 2\n\n\n\n\nbase R rowMeans\nThe rowMeans() function works, but why the x and what do the dots mean??\n\nsurvey_means_base &lt;- survey %&gt;%\n  mutate(item_mean = rowMeans(x = select(.data = . , starts_with(match = \"item\"))))\n\n\n\ntidyverse rowwise\nThe tidyverse version involves using rowwise() to tell R that you would like a mean calculated for each row in the dataset. Use c() to tell R which columns to average across.\nWithout rowwise(), R will calculate the mean of all rows/columns and put that in the new variable. You will end up with the same value for each row.\n\nsurvey_means_norowwise &lt;- survey %&gt;%\n  mutate(item_mean = mean(c(item1, item2, item3, item4, item5))) \n\nglimpse(survey_means_norowwise)\n\nRows: 6\nColumns: 7\n$ pID       &lt;chr&gt; \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"\n$ item1     &lt;int&gt; 5, 7, 5, 4, 6, 4\n$ item2     &lt;int&gt; 2, 3, 1, 2, 6, 1\n$ item3     &lt;int&gt; 5, 3, 1, 4, 3, 6\n$ item4     &lt;int&gt; 4, 4, 1, 1, 7, 7\n$ item5     &lt;int&gt; 6, 6, 5, 4, 6, 2\n$ item_mean &lt;dbl&gt; 4.033333, 4.033333, 4.033333, 4.033333, 4.033333, 4.033333\n\n\nWith rowwise(), it calculates across the rows, separately for each participant.\n\n\n\n\n\n\nNote\n\n\n\nIt is important to get into the habit of adding ungroup() after a rowwise() in the same way as you would after a group_by() because the dataframe becomes grouped by row, which can mess with calcuations further down the pipeline.\n\n\n\nsurvey_means_rowwise &lt;- survey %&gt;%\n  rowwise() %&gt;%\n  mutate(item_mean = mean(c(item1, item2, item3, item4, item5))) %&gt;%\n  ungroup()\n\nglimpse(survey_means_rowwise)\n\nRows: 6\nColumns: 7\n$ pID       &lt;chr&gt; \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"\n$ item1     &lt;int&gt; 5, 7, 5, 4, 6, 4\n$ item2     &lt;int&gt; 2, 3, 1, 2, 6, 1\n$ item3     &lt;int&gt; 5, 3, 1, 4, 3, 6\n$ item4     &lt;int&gt; 4, 4, 1, 1, 7, 7\n$ item5     &lt;int&gt; 6, 6, 5, 4, 6, 2\n$ item_mean &lt;dbl&gt; 4.4, 4.6, 2.6, 3.0, 5.6, 4.0\n\n\nIf there are a lot of columns to average across, you can avoid typing all of the names using c_across().\n\nsurvey_means_rowwise_across &lt;- survey %&gt;%\n  rowwise() %&gt;%\n  mutate(item_mean = mean(c_across(item1:item5))) %&gt;%\n  ungroup()\n\nglimpse(survey_means_rowwise_across)\n\nRows: 6\nColumns: 7\n$ pID       &lt;chr&gt; \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\"\n$ item1     &lt;int&gt; 5, 7, 5, 4, 6, 4\n$ item2     &lt;int&gt; 2, 3, 1, 2, 6, 1\n$ item3     &lt;int&gt; 5, 3, 1, 4, 3, 6\n$ item4     &lt;int&gt; 4, 4, 1, 1, 7, 7\n$ item5     &lt;int&gt; 6, 6, 5, 4, 6, 2\n$ item_mean &lt;dbl&gt; 4.4, 4.6, 2.6, 3.0, 5.6, 4.0"
  }
]